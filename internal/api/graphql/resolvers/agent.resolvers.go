package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/adapters/ai"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/agent"
	agentService "prometheus/internal/services/agent"
	"prometheus/pkg/relay"

	"github.com/google/uuid"
)

// ModelProvider is the resolver for the modelProvider field.
func (r *agentResolver) ModelProvider(ctx context.Context, obj *agent.Agent) (*string, error) {
	str := string(obj.ModelProvider)
	return &str, nil
}

// ModelName is the resolver for the modelName field.
func (r *agentResolver) ModelName(ctx context.Context, obj *agent.Agent) (*string, error) {
	str := string(obj.ModelName)
	return &str, nil
}

// AvailableTools is the resolver for the availableTools field.
func (r *agentResolver) AvailableTools(ctx context.Context, obj *agent.Agent) (map[string]any, error) {
	tools, err := obj.GetAvailableTools()
	if err != nil {
		return nil, fmt.Errorf("failed to parse available tools: %w", err)
	}
	// Convert []string to map[string]any for GraphQL JSONObject
	result := make(map[string]any)
	if len(tools) > 0 {
		result["tools"] = tools
	}
	return result, nil
}

// CreateAgent is the resolver for the createAgent field.
func (r *mutationResolver) CreateAgent(ctx context.Context, input generated.CreateAgentInput) (*agent.Agent, error) {
	// Extract required fields with defaults
	identifier := ""
	if input.Identifier != nil {
		identifier = *input.Identifier
	}
	name := ""
	if input.Name != nil {
		name = *input.Name
	}
	description := ""
	if input.Description != nil {
		description = *input.Description
	}
	category := ""
	if input.Category != nil {
		category = *input.Category
	}
	systemPrompt := ""
	if input.SystemPrompt != nil {
		systemPrompt = *input.SystemPrompt
	}
	instructions := ""
	if input.Instructions != nil {
		instructions = *input.Instructions
	}
	modelProvider := ai.ProviderNameDeepSeek // default
	if input.ModelProvider != nil {
		modelProvider = ai.ProviderName(*input.ModelProvider)
	}
	modelName := ai.ModelDeepSeekReasoner // default
	if input.ModelName != nil {
		modelName = ai.ProviderModelName(*input.ModelName)
	}

	// Set defaults
	temperature := 1.0
	if input.Temperature != nil {
		temperature = *input.Temperature
	}
	maxTokens := 4000
	if input.MaxTokens != nil {
		maxTokens = *input.MaxTokens
	}
	maxCostPerRun := 0.10
	if input.MaxCostPerRun != nil {
		maxCostPerRun = *input.MaxCostPerRun
	}
	timeoutSeconds := 60
	if input.TimeoutSeconds != nil {
		timeoutSeconds = *input.TimeoutSeconds
	}
	isActive := true
	if input.IsActive != nil {
		isActive = *input.IsActive
	}

	// Parse available tools from JSONObject
	availableTools := []string{}
	if input.AvailableTools != nil {
		if toolsList, ok := input.AvailableTools["tools"].([]interface{}); ok {
			for _, t := range toolsList {
				if toolStr, ok := t.(string); ok {
					availableTools = append(availableTools, toolStr)
				}
			}
		}
	}

	params := agentService.CreateAgentParams{
		Identifier:     identifier,
		Name:           name,
		Description:    description,
		Category:       category,
		SystemPrompt:   systemPrompt,
		Instructions:   instructions,
		ModelProvider:  modelProvider,
		ModelName:      modelName,
		Temperature:    temperature,
		MaxTokens:      maxTokens,
		AvailableTools: availableTools,
		MaxCostPerRun:  maxCostPerRun,
		TimeoutSeconds: timeoutSeconds,
		IsActive:       isActive,
	}

	return r.AgentService.CreateAgent(ctx, params)
}

// UpdateAgent is the resolver for the updateAgent field.
func (r *mutationResolver) UpdateAgent(ctx context.Context, id uuid.UUID, input generated.UpdateAgentInput) (*agent.Agent, error) {
	var modelProvider *ai.ProviderName
	if input.ModelProvider != nil {
		mp := ai.ProviderName(*input.ModelProvider)
		modelProvider = &mp
	}

	var modelName *ai.ProviderModelName
	if input.ModelName != nil {
		mn := ai.ProviderModelName(*input.ModelName)
		modelName = &mn
	}

	// Parse available tools from JSONObject
	var availableTools []string
	if input.AvailableTools != nil {
		if toolsList, ok := input.AvailableTools["tools"].([]interface{}); ok {
			for _, t := range toolsList {
				if toolStr, ok := t.(string); ok {
					availableTools = append(availableTools, toolStr)
				}
			}
		}
	}

	params := agentService.UpdateAgentParams{
		Name:           input.Name,
		Description:    input.Description,
		Category:       input.Category,
		SystemPrompt:   input.SystemPrompt,
		Instructions:   input.Instructions,
		ModelProvider:  modelProvider,
		ModelName:      modelName,
		Temperature:    input.Temperature,
		MaxTokens:      input.MaxTokens,
		AvailableTools: availableTools,
		MaxCostPerRun:  input.MaxCostPerRun,
		TimeoutSeconds: input.TimeoutSeconds,
	}

	return r.AgentService.UpdateAgent(ctx, id, params)
}

// DeleteAgent is the resolver for the deleteAgent field.
func (r *mutationResolver) DeleteAgent(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.AgentService.DeleteAgent(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// BatchDeleteAgents is the resolver for the batchDeleteAgents field.
func (r *mutationResolver) BatchDeleteAgents(ctx context.Context, ids []uuid.UUID) (int, error) {
	return r.AgentService.BatchDeleteAgents(ctx, ids)
}

// SetAgentActive is the resolver for the setAgentActive field.
func (r *mutationResolver) SetAgentActive(ctx context.Context, id uuid.UUID, isActive bool) (*agent.Agent, error) {
	return r.AgentService.SetActive(ctx, id, isActive)
}

// UpdateAgentPrompt is the resolver for the updateAgentPrompt field.
func (r *mutationResolver) UpdateAgentPrompt(ctx context.Context, id uuid.UUID, systemPrompt string) (*agent.Agent, error) {
	return r.AgentService.UpdatePromptByID(ctx, id, systemPrompt)
}

// EnsureSystemAgents is the resolver for the ensureSystemAgents field.
func (r *mutationResolver) EnsureSystemAgents(ctx context.Context) (bool, error) {
	if err := r.AgentService.EnsureSystemAgents(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// Agent is the resolver for the agent field.
func (r *queryResolver) Agent(ctx context.Context, id uuid.UUID) (*agent.Agent, error) {
	return r.AgentService.GetByID(ctx, id)
}

// AgentByIdentifier is the resolver for the agentByIdentifier field.
func (r *queryResolver) AgentByIdentifier(ctx context.Context, identifier string) (*agent.Agent, error) {
	return r.AgentService.GetByIdentifier(ctx, identifier)
}

// Agents is the resolver for the agents field.
func (r *queryResolver) Agents(ctx context.Context, scope *string, search *string, filters map[string]any, first *int, after *string, last *int, before *string) (*generated.AgentConnection, error) {
	// Get filtered agents from service
	filtered, err := r.AgentService.GetAgentsWithScope(ctx, scope, search, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to get agents: %w", err)
	}

	// Get scope counts from service
	scopeCounts, err := r.AgentService.GetAgentsScopes(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get scope counts: %w", err)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(filtered)
	paginationOffset, paginationLimit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := paginationOffset + paginationLimit
	if end > totalCount {
		end = totalCount
	}
	if paginationOffset > totalCount {
		paginationOffset = totalCount
	}

	items := filtered[paginationOffset:end]

	// Build connection with scopes and filters
	return buildAgentConnection(items, totalCount, params, paginationOffset, scopeCounts)
}

// Agent returns generated.AgentResolver implementation.
func (r *Resolver) Agent() generated.AgentResolver { return &agentResolver{r} }

type agentResolver struct{ *Resolver }
