package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/adapters/ai"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/agent"
	agentService "prometheus/internal/services/agent"
	"prometheus/pkg/relay"
)

// ModelProvider is the resolver for the modelProvider field.
func (r *agentResolver) ModelProvider(ctx context.Context, obj *agent.Agent) (string, error) {
	return string(obj.ModelProvider), nil
}

// ModelName is the resolver for the modelName field.
func (r *agentResolver) ModelName(ctx context.Context, obj *agent.Agent) (string, error) {
	return string(obj.ModelName), nil
}

// AvailableTools is the resolver for the availableTools field.
func (r *agentResolver) AvailableTools(ctx context.Context, obj *agent.Agent) ([]string, error) {
	tools, err := obj.GetAvailableTools()
	if err != nil {
		return nil, fmt.Errorf("failed to parse available tools: %w", err)
	}
	return tools, nil
}

// CreateAgent is the resolver for the createAgent field.
func (r *mutationResolver) CreateAgent(ctx context.Context, input generated.CreateAgentInput) (*agent.Agent, error) {
	// Set defaults
	temperature := 1.0
	if input.Temperature != nil {
		temperature = *input.Temperature
	}
	maxTokens := 4000
	if input.MaxTokens != nil {
		maxTokens = *input.MaxTokens
	}
	maxCostPerRun := 0.10
	if input.MaxCostPerRun != nil {
		maxCostPerRun = *input.MaxCostPerRun
	}
	timeoutSeconds := 60
	if input.TimeoutSeconds != nil {
		timeoutSeconds = *input.TimeoutSeconds
	}
	isActive := true
	if input.IsActive != nil {
		isActive = *input.IsActive
	}

	// Available tools default to empty array
	availableTools := []string{}
	if input.AvailableTools != nil {
		availableTools = input.AvailableTools
	}

	instructions := ""
	if input.Instructions != nil {
		instructions = *input.Instructions
	}

	params := agentService.CreateAgentParams{
		Identifier:     input.Identifier,
		Name:           input.Name,
		Description:    input.Description,
		Category:       input.Category,
		SystemPrompt:   input.SystemPrompt,
		Instructions:   instructions,
		ModelProvider:  ai.ProviderName(input.ModelProvider),
		ModelName:      ai.ProviderModelName(input.ModelName),
		Temperature:    temperature,
		MaxTokens:      maxTokens,
		AvailableTools: availableTools,
		MaxCostPerRun:  maxCostPerRun,
		TimeoutSeconds: timeoutSeconds,
		IsActive:       isActive,
	}

	return r.AgentService.CreateAgent(ctx, params)
}

// UpdateAgent is the resolver for the updateAgent field.
func (r *mutationResolver) UpdateAgent(ctx context.Context, id int, input generated.UpdateAgentInput) (*agent.Agent, error) {
	var modelProvider *ai.ProviderName
	if input.ModelProvider != nil {
		mp := ai.ProviderName(*input.ModelProvider)
		modelProvider = &mp
	}

	var modelName *ai.ProviderModelName
	if input.ModelName != nil {
		mn := ai.ProviderModelName(*input.ModelName)
		modelName = &mn
	}

	params := agentService.UpdateAgentParams{
		Name:           input.Name,
		Description:    input.Description,
		Category:       input.Category,
		SystemPrompt:   input.SystemPrompt,
		Instructions:   input.Instructions,
		ModelProvider:  modelProvider,
		ModelName:      modelName,
		Temperature:    input.Temperature,
		MaxTokens:      input.MaxTokens,
		AvailableTools: input.AvailableTools,
		MaxCostPerRun:  input.MaxCostPerRun,
		TimeoutSeconds: input.TimeoutSeconds,
	}

	return r.AgentService.UpdateAgent(ctx, id, params)
}

// DeleteAgent is the resolver for the deleteAgent field.
func (r *mutationResolver) DeleteAgent(ctx context.Context, id int) (bool, error) {
	if err := r.AgentService.DeleteAgent(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// BatchDeleteAgents is the resolver for the batchDeleteAgents field.
func (r *mutationResolver) BatchDeleteAgents(ctx context.Context, ids []int) (int, error) {
	return r.AgentService.BatchDeleteAgents(ctx, ids)
}

// SetAgentActive is the resolver for the setAgentActive field.
func (r *mutationResolver) SetAgentActive(ctx context.Context, id int, isActive bool) (*agent.Agent, error) {
	return r.AgentService.SetActive(ctx, id, isActive)
}

// UpdateAgentPrompt is the resolver for the updateAgentPrompt field.
func (r *mutationResolver) UpdateAgentPrompt(ctx context.Context, id int, systemPrompt string) (*agent.Agent, error) {
	return r.AgentService.UpdatePromptByID(ctx, id, systemPrompt)
}

// EnsureSystemAgents is the resolver for the ensureSystemAgents field.
func (r *mutationResolver) EnsureSystemAgents(ctx context.Context) (bool, error) {
	if err := r.AgentService.EnsureSystemAgents(ctx); err != nil {
		return false, err
	}
	return true, nil
}

// Agent is the resolver for the agent field.
func (r *queryResolver) Agent(ctx context.Context, id int) (*agent.Agent, error) {
	return r.AgentService.GetByID(ctx, id)
}

// AgentByIdentifier is the resolver for the agentByIdentifier field.
func (r *queryResolver) AgentByIdentifier(ctx context.Context, identifier string) (*agent.Agent, error) {
	return r.AgentService.GetByIdentifier(ctx, identifier)
}

// Agents is the resolver for the agents field.
func (r *queryResolver) Agents(ctx context.Context, category *string, isActive *bool, first *int, after *string, last *int, before *string) (*generated.AgentConnection, error) {
	// Get all agents
	var allAgents []*agent.Agent
	var err error

	if category != nil {
		allAgents, err = r.AgentService.ListByCategory(ctx, *category)
	} else if isActive != nil && *isActive {
		allAgents, err = r.AgentService.ListActive(ctx)
	} else {
		allAgents, err = r.AgentService.List(ctx)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to get agents: %w", err)
	}

	// Filter by isActive if provided (and not already filtered by ListActive)
	filtered := allAgents
	if isActive != nil && !(category == nil && *isActive) {
		filtered = make([]*agent.Agent, 0)
		for _, a := range allAgents {
			if a.IsActive == *isActive {
				filtered = append(filtered, a)
			}
		}
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(filtered)
	paginationOffset, paginationLimit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := paginationOffset + paginationLimit
	if end > totalCount {
		end = totalCount
	}
	if paginationOffset > totalCount {
		paginationOffset = totalCount
	}

	items := filtered[paginationOffset:end]

	// Build relay connection
	conn, err := relay.NewConnection(items, totalCount, params, paginationOffset)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection: %w", err)
	}

	// Convert to GraphQL types
	edges := make([]*generated.AgentEdge, len(conn.Edges))
	for i, edge := range conn.Edges {
		edges[i] = &generated.AgentEdge{
			Node:   edge.Node,
			Cursor: edge.Cursor,
		}
	}

	return &generated.AgentConnection{
		Edges: edges,
		PageInfo: &generated.PageInfo{
			HasNextPage:     conn.PageInfo.HasNextPage,
			HasPreviousPage: conn.PageInfo.HasPreviousPage,
			StartCursor:     conn.PageInfo.StartCursor,
			EndCursor:       conn.PageInfo.EndCursor,
		},
		TotalCount: conn.TotalCount,
	}, nil
}

// Agent returns generated.AgentResolver implementation.
func (r *Resolver) Agent() generated.AgentResolver { return &agentResolver{r} }

type agentResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) DeleteManyAgents(ctx context.Context, ids []int) (int, error) {
	return r.AgentService.DeleteManyAgents(ctx, ids)
}
*/
