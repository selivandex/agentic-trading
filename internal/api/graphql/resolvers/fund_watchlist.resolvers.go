package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/fundwatchlist"
	"prometheus/pkg/relay"

	"github.com/google/uuid"
)

// MarketType is the resolver for the marketType field.
func (r *fundWatchlistResolver) MarketType(ctx context.Context, obj *fundwatchlist.Watchlist) (string, error) {
	return obj.MarketType, nil
}

// CreateFundWatchlist is the resolver for the createFundWatchlist field.
func (r *mutationResolver) CreateFundWatchlist(ctx context.Context, input generated.CreateFundWatchlistInput) (*fundwatchlist.Watchlist, error) {
	entry := &fundwatchlist.Watchlist{
		ID:         uuid.New(),
		Symbol:     input.Symbol,
		MarketType: input.MarketType,
		Category:   input.Category,
		Tier:       input.Tier,
		IsActive:   true,
		IsPaused:   false,
	}

	if err := r.FundWatchlistService.Create(ctx, entry); err != nil {
		return nil, fmt.Errorf("failed to create fund watchlist: %w", err)
	}

	return entry, nil
}

// UpdateFundWatchlist is the resolver for the updateFundWatchlist field.
func (r *mutationResolver) UpdateFundWatchlist(ctx context.Context, id uuid.UUID, input generated.UpdateFundWatchlistInput) (*fundwatchlist.Watchlist, error) {
	entry, err := r.FundWatchlistService.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get fund watchlist: %w", err)
	}

	// Update fields if provided
	if input.Category != nil {
		entry.Category = *input.Category
	}
	if input.Tier != nil {
		entry.Tier = *input.Tier
	}
	if input.IsActive != nil {
		entry.IsActive = *input.IsActive
	}
	if input.IsPaused != nil {
		entry.IsPaused = *input.IsPaused
	}
	if input.PausedReason != nil {
		entry.PausedReason = input.PausedReason
	}

	if err := r.FundWatchlistService.Update(ctx, entry); err != nil {
		return nil, fmt.Errorf("failed to update fund watchlist: %w", err)
	}

	return entry, nil
}

// DeleteFundWatchlist is the resolver for the deleteFundWatchlist field.
func (r *mutationResolver) DeleteFundWatchlist(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.FundWatchlistService.Delete(ctx, id); err != nil {
		return false, fmt.Errorf("failed to delete fund watchlist: %w", err)
	}
	return true, nil
}

// ToggleFundWatchlistPause is the resolver for the toggleFundWatchlistPause field.
func (r *mutationResolver) ToggleFundWatchlistPause(ctx context.Context, id uuid.UUID, isPaused bool, reason *string) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.TogglePause(ctx, id, isPaused, reason)
}

// FundWatchlist is the resolver for the fundWatchlist field.
func (r *queryResolver) FundWatchlist(ctx context.Context, id uuid.UUID) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetByID(ctx, id)
}

// FundWatchlistBySymbol is the resolver for the fundWatchlistBySymbol field.
func (r *queryResolver) FundWatchlistBySymbol(ctx context.Context, symbol string, marketType string) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetBySymbol(ctx, symbol, marketType)
}

// FundWatchlists is the resolver for the fundWatchlists field.
func (r *queryResolver) FundWatchlists(ctx context.Context, limit *int, offset *int, isActive *bool, category *string, tier *int) ([]*fundwatchlist.Watchlist, error) {
	// For simplicity, return all for now
	// TODO: implement filtering by limit, offset, isActive, category, tier
	return r.FundWatchlistService.GetAll(ctx)
}

// MonitoredSymbols is the resolver for the monitoredSymbols field.
func (r *queryResolver) MonitoredSymbols(ctx context.Context, marketType *string) ([]*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetMonitored(ctx, marketType)
}

// FundWatchlistsConnection is the resolver for the fundWatchlistsConnection field.
func (r *queryResolver) FundWatchlistsConnection(ctx context.Context, isActive *bool, category *string, tier *int, first *int, after *string, last *int, before *string) (*generated.FundWatchlistConnection, error) {
	// Get all watchlist items
	allItems, err := r.FundWatchlistService.GetAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get watchlist items: %w", err)
	}

	// Filter by criteria
	filtered := make([]*fundwatchlist.Watchlist, 0)
	for _, item := range allItems {
		if isActive != nil && item.IsActive != *isActive {
			continue
		}
		if category != nil && item.Category != *category {
			continue
		}
		if tier != nil && item.Tier != *tier {
			continue
		}
		filtered = append(filtered, item)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(filtered)
	offset, limit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := offset + limit
	if end > totalCount {
		end = totalCount
	}
	if offset > totalCount {
		offset = totalCount
	}

	items := filtered[offset:end]

	// Build relay connection
	conn, err := relay.NewConnection(items, totalCount, params, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection: %w", err)
	}

	// Convert to GraphQL types
	edges := make([]*generated.FundWatchlistEdge, len(conn.Edges))
	for i, edge := range conn.Edges {
		edges[i] = &generated.FundWatchlistEdge{
			Node:   edge.Node,
			Cursor: edge.Cursor,
		}
	}

	return &generated.FundWatchlistConnection{
		Edges: edges,
		PageInfo: &generated.PageInfo{
			HasNextPage:     conn.PageInfo.HasNextPage,
			HasPreviousPage: conn.PageInfo.HasPreviousPage,
			StartCursor:     conn.PageInfo.StartCursor,
			EndCursor:       conn.PageInfo.EndCursor,
		},
		TotalCount: conn.TotalCount,
	}, nil
}

// MonitoredSymbolsConnection is the resolver for the monitoredSymbolsConnection field.
func (r *queryResolver) MonitoredSymbolsConnection(ctx context.Context, marketType *string, first *int, after *string, last *int, before *string) (*generated.FundWatchlistConnection, error) {
	// Get monitored symbols
	allItems, err := r.FundWatchlistService.GetMonitored(ctx, marketType)
	if err != nil {
		return nil, fmt.Errorf("failed to get monitored symbols: %w", err)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(allItems)
	offset, limit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := offset + limit
	if end > totalCount {
		end = totalCount
	}
	if offset > totalCount {
		offset = totalCount
	}

	items := allItems[offset:end]

	// Build relay connection
	conn, err := relay.NewConnection(items, totalCount, params, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection: %w", err)
	}

	// Convert to GraphQL types
	edges := make([]*generated.FundWatchlistEdge, len(conn.Edges))
	for i, edge := range conn.Edges {
		edges[i] = &generated.FundWatchlistEdge{
			Node:   edge.Node,
			Cursor: edge.Cursor,
		}
	}

	return &generated.FundWatchlistConnection{
		Edges: edges,
		PageInfo: &generated.PageInfo{
			HasNextPage:     conn.PageInfo.HasNextPage,
			HasPreviousPage: conn.PageInfo.HasPreviousPage,
			StartCursor:     conn.PageInfo.StartCursor,
			EndCursor:       conn.PageInfo.EndCursor,
		},
		TotalCount: conn.TotalCount,
	}, nil
}

// FundWatchlist returns generated.FundWatchlistResolver implementation.
func (r *Resolver) FundWatchlist() generated.FundWatchlistResolver { return &fundWatchlistResolver{r} }

type fundWatchlistResolver struct{ *Resolver }
