package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/fundwatchlist"

	"github.com/google/uuid"
)

// MarketType is the resolver for the marketType field.
func (r *fundWatchlistResolver) MarketType(ctx context.Context, obj *fundwatchlist.Watchlist) (string, error) {
	return obj.MarketType, nil
}

// CreateFundWatchlist is the resolver for the createFundWatchlist field.
func (r *mutationResolver) CreateFundWatchlist(ctx context.Context, input generated.CreateFundWatchlistInput) (*fundwatchlist.Watchlist, error) {
	entry := &fundwatchlist.Watchlist{
		ID:         uuid.New(),
		Symbol:     input.Symbol,
		MarketType: input.MarketType,
		Category:   input.Category,
		Tier:       input.Tier,
		IsActive:   true,
		IsPaused:   false,
	}

	if err := r.FundWatchlistService.Create(ctx, entry); err != nil {
		return nil, fmt.Errorf("failed to create fund watchlist: %w", err)
	}

	return entry, nil
}

// UpdateFundWatchlist is the resolver for the updateFundWatchlist field.
func (r *mutationResolver) UpdateFundWatchlist(ctx context.Context, id uuid.UUID, input generated.UpdateFundWatchlistInput) (*fundwatchlist.Watchlist, error) {
	entry, err := r.FundWatchlistService.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get fund watchlist: %w", err)
	}

	// Update fields if provided
	if input.Category != nil {
		entry.Category = *input.Category
	}
	if input.Tier != nil {
		entry.Tier = *input.Tier
	}
	if input.IsActive != nil {
		entry.IsActive = *input.IsActive
	}
	if input.IsPaused != nil {
		entry.IsPaused = *input.IsPaused
	}
	if input.PausedReason != nil {
		entry.PausedReason = input.PausedReason
	}

	if err := r.FundWatchlistService.Update(ctx, entry); err != nil {
		return nil, fmt.Errorf("failed to update fund watchlist: %w", err)
	}

	return entry, nil
}

// DeleteFundWatchlist is the resolver for the deleteFundWatchlist field.
func (r *mutationResolver) DeleteFundWatchlist(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.FundWatchlistService.Delete(ctx, id); err != nil {
		return false, fmt.Errorf("failed to delete fund watchlist: %w", err)
	}
	return true, nil
}

// ToggleFundWatchlistPause is the resolver for the toggleFundWatchlistPause field.
func (r *mutationResolver) ToggleFundWatchlistPause(ctx context.Context, id uuid.UUID, isPaused bool, reason *string) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.TogglePause(ctx, id, isPaused, reason)
}

// FundWatchlist is the resolver for the fundWatchlist field.
func (r *queryResolver) FundWatchlist(ctx context.Context, id uuid.UUID) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetByID(ctx, id)
}

// FundWatchlistBySymbol is the resolver for the fundWatchlistBySymbol field.
func (r *queryResolver) FundWatchlistBySymbol(ctx context.Context, symbol string, marketType string) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetBySymbol(ctx, symbol, marketType)
}

// FundWatchlists is the resolver for the fundWatchlists field.
func (r *queryResolver) FundWatchlists(ctx context.Context, limit *int, offset *int, isActive *bool, category *string, tier *int) ([]*fundwatchlist.Watchlist, error) {
	// For simplicity, return all for now
	// TODO: implement filtering by limit, offset, isActive, category, tier
	return r.FundWatchlistService.GetAll(ctx)
}

// MonitoredSymbols is the resolver for the monitoredSymbols field.
func (r *queryResolver) MonitoredSymbols(ctx context.Context, marketType *string) ([]*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetMonitored(ctx, marketType)
}

// FundWatchlist returns generated.FundWatchlistResolver implementation.
func (r *Resolver) FundWatchlist() generated.FundWatchlistResolver { return &fundWatchlistResolver{r} }

type fundWatchlistResolver struct{ *Resolver }
