package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/fundwatchlist"
	fundWatchlistService "prometheus/internal/services/fundwatchlist"
	"prometheus/pkg/relay"

	"github.com/google/uuid"
)

// MarketType is the resolver for the marketType field.
func (r *fundWatchlistResolver) MarketType(ctx context.Context, obj *fundwatchlist.Watchlist) (string, error) {
	return obj.MarketType, nil
}

// CreateFundWatchlist is the resolver for the createFundWatchlist field.
func (r *mutationResolver) CreateFundWatchlist(ctx context.Context, input generated.CreateFundWatchlistInput) (*fundwatchlist.Watchlist, error) {
	params := fundWatchlistService.CreateWatchlistParams{
		Symbol:     input.Symbol,
		MarketType: input.MarketType,
		Category:   input.Category,
		Tier:       input.Tier,
	}

	return r.FundWatchlistService.CreateWatchlist(ctx, params)
}

// UpdateFundWatchlist is the resolver for the updateFundWatchlist field.
func (r *mutationResolver) UpdateFundWatchlist(ctx context.Context, id uuid.UUID, input generated.UpdateFundWatchlistInput) (*fundwatchlist.Watchlist, error) {
	params := fundWatchlistService.UpdateWatchlistParams{
		Category:     input.Category,
		Tier:         input.Tier,
		IsActive:     input.IsActive,
		IsPaused:     input.IsPaused,
		PausedReason: input.PausedReason,
	}

	return r.FundWatchlistService.UpdateWatchlist(ctx, id, params)
}

// DeleteFundWatchlist is the resolver for the deleteFundWatchlist field.
func (r *mutationResolver) DeleteFundWatchlist(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.FundWatchlistService.DeleteWatchlist(ctx, id); err != nil {
		return false, fmt.Errorf("failed to delete fund watchlist: %w", err)
	}
	return true, nil
}

// BatchDeleteFundWatchlists is the resolver for the batchDeleteFundWatchlists field.
func (r *mutationResolver) BatchDeleteFundWatchlists(ctx context.Context, ids []uuid.UUID) (int, error) {
	return r.FundWatchlistService.BatchDeleteWatchlists(ctx, ids)
}

// ToggleFundWatchlistPause is the resolver for the toggleFundWatchlistPause field.
func (r *mutationResolver) ToggleFundWatchlistPause(ctx context.Context, id uuid.UUID, isPaused bool, reason *string) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.TogglePause(ctx, id, isPaused, reason)
}

// FundWatchlist is the resolver for the fundWatchlist field.
func (r *queryResolver) FundWatchlist(ctx context.Context, id uuid.UUID) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetByID(ctx, id)
}

// FundWatchlistBySymbol is the resolver for the fundWatchlistBySymbol field.
func (r *queryResolver) FundWatchlistBySymbol(ctx context.Context, symbol string, marketType string) (*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetBySymbol(ctx, symbol, marketType)
}

// FundWatchlists is the resolver for the fundWatchlists field.
func (r *queryResolver) FundWatchlists(ctx context.Context, limit *int, offset *int, isActive *bool, category *string, tier *int) ([]*fundwatchlist.Watchlist, error) {
	// For simplicity, return all for now
	// TODO: implement filtering by limit, offset, isActive, category, tier
	return r.FundWatchlistService.GetAll(ctx)
}

// MonitoredSymbols is the resolver for the monitoredSymbols field.
func (r *queryResolver) MonitoredSymbols(ctx context.Context, marketType *string) ([]*fundwatchlist.Watchlist, error) {
	return r.FundWatchlistService.GetMonitored(ctx, marketType)
}

// FundWatchlistsConnection is the resolver for the fundWatchlistsConnection field.
func (r *queryResolver) FundWatchlistsConnection(ctx context.Context, scope *string, isActive *bool, category *string, tier *int, search *string, filters map[string]any, first *int, after *string, last *int, before *string) (*generated.FundWatchlistConnection, error) {
	// Use scope parameter if provided, otherwise fall back to legacy isActive parameter
	effectiveScope := scope
	if effectiveScope == nil && isActive != nil {
		// Legacy support: map isActive to scope
		if *isActive {
			scopeStr := "active"
			effectiveScope = &scopeStr
		} else {
			scopeStr := "inactive"
			effectiveScope = &scopeStr
		}
	}

	// Build filters map from GraphQL params (merge with explicit filters param)
	mergedFilters := make(map[string]interface{})

	// Add filters from map parameter
	if filters != nil {
		for k, v := range filters {
			mergedFilters[k] = v
		}
	}

	// Add legacy parameters (for backward compatibility)
	if category != nil {
		mergedFilters["category"] = *category
	}
	if tier != nil {
		// Convert single tier to array for multiselect filter
		mergedFilters["tier"] = []interface{}{float64(*tier)}
	}

	// Get filtered watchlist items from service (uses SQL WHERE, not in-memory filtering)
	filtered, err := r.FundWatchlistService.GetWatchlistsWithScope(ctx, effectiveScope, search, mergedFilters)
	if err != nil {
		return nil, fmt.Errorf("failed to get watchlist items: %w", err)
	}

	// Get scope counts from service (uses SQL GROUP BY)
	scopeCounts, err := r.FundWatchlistService.GetWatchlistsScopes(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get scope counts: %w", err)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(filtered)
	offset, limit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := offset + limit
	if end > totalCount {
		end = totalCount
	}
	if offset > totalCount {
		offset = totalCount
	}

	items := filtered[offset:end]

	// Build connection with scopes and filters using helper
	return buildFundWatchlistConnection(items, totalCount, params, offset, scopeCounts)
}

// MonitoredSymbolsConnection is the resolver for the monitoredSymbolsConnection field.
func (r *queryResolver) MonitoredSymbolsConnection(ctx context.Context, scope *string, marketType *string, first *int, after *string, last *int, before *string) (*generated.FundWatchlistConnection, error) {
	// Build filters map for monitored symbols (active and not paused)
	filters := make(map[string]interface{})
	if marketType != nil {
		filters["market_type"] = *marketType
	}

	// Monitored = active scope
	activeScope := "active"

	// Get monitored watchlist items from service
	allItems, err := r.FundWatchlistService.GetWatchlistsWithScope(ctx, &activeScope, nil, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to get monitored symbols: %w", err)
	}

	// Get scope counts from service
	scopeCounts, err := r.FundWatchlistService.GetWatchlistsScopes(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get scope counts: %w", err)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(allItems)
	offset, limit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := offset + limit
	if end > totalCount {
		end = totalCount
	}
	if offset > totalCount {
		offset = totalCount
	}

	items := allItems[offset:end]

	// Build connection with scopes and filters using helper
	return buildFundWatchlistConnection(items, totalCount, params, offset, scopeCounts)
}

// FundWatchlist returns generated.FundWatchlistResolver implementation.
func (r *Resolver) FundWatchlist() generated.FundWatchlistResolver { return &fundWatchlistResolver{r} }

type fundWatchlistResolver struct{ *Resolver }
