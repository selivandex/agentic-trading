package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/user"
	userService "prometheus/internal/services/user"
	"prometheus/pkg/relay"

	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*user.User, error) {
	// Parse telegram ID if provided
	var telegramID *int64
	if input.TelegramID != nil && *input.TelegramID != "" {
		var tid int64
		if _, err := fmt.Sscanf(*input.TelegramID, "%d", &tid); err != nil {
			return nil, fmt.Errorf("invalid telegram ID: %w", err)
		}
		telegramID = &tid
	}

	// Parse settings if provided
	var settings *user.Settings
	if input.Settings != nil {
		s := user.DefaultSettings()
		if input.Settings.DefaultAIProvider != nil {
			s.DefaultAIProvider = *input.Settings.DefaultAIProvider
		}
		if input.Settings.DefaultAIModel != nil {
			s.DefaultAIModel = *input.Settings.DefaultAIModel
		}
		if input.Settings.RiskLevel != nil {
			s.RiskLevel = *input.Settings.RiskLevel
		}
		if input.Settings.MaxPositions != nil {
			s.MaxPositions = *input.Settings.MaxPositions
		}
		if input.Settings.MaxPortfolioRisk != nil {
			s.MaxPortfolioRisk = *input.Settings.MaxPortfolioRisk
		}
		if input.Settings.MaxDailyDrawdown != nil {
			s.MaxDailyDrawdown = *input.Settings.MaxDailyDrawdown
		}
		if input.Settings.MaxConsecutiveLoss != nil {
			s.MaxConsecutiveLoss = *input.Settings.MaxConsecutiveLoss
		}
		if input.Settings.NotificationsOn != nil {
			s.NotificationsOn = *input.Settings.NotificationsOn
		}
		if input.Settings.DailyReportTime != nil {
			s.DailyReportTime = *input.Settings.DailyReportTime
		}
		if input.Settings.Timezone != nil {
			s.Timezone = *input.Settings.Timezone
		}
		if input.Settings.CircuitBreakerOn != nil {
			s.CircuitBreakerOn = *input.Settings.CircuitBreakerOn
		}
		if input.Settings.MaxPositionSizeUsd != nil {
			s.MaxPositionSizeUSD = *input.Settings.MaxPositionSizeUsd
		}
		if input.Settings.MaxTotalExposureUsd != nil {
			s.MaxTotalExposureUSD = *input.Settings.MaxTotalExposureUsd
		}
		if input.Settings.MinPositionSizeUsd != nil {
			s.MinPositionSizeUSD = *input.Settings.MinPositionSizeUsd
		}
		if input.Settings.MaxLeverageMultiple != nil {
			s.MaxLeverageMultiple = *input.Settings.MaxLeverageMultiple
		}
		if input.Settings.AllowedExchanges != nil {
			s.AllowedExchanges = input.Settings.AllowedExchanges
		}
		settings = &s
	}

	// Set defaults
	isActive := true
	if input.IsActive != nil {
		isActive = *input.IsActive
	}
	isPremium := false
	if input.IsPremium != nil {
		isPremium = *input.IsPremium
	}

	params := userService.CreateUserParams{
		TelegramID: telegramID,
		TelegramUsername: func() string {
			if input.TelegramUsername == nil {
				return ""
			}
			return *input.TelegramUsername
		}(),
		Email:          input.Email,
		PasswordHash:   input.PasswordHash,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		LanguageCode:   input.LanguageCode,
		IsActive:       isActive,
		IsPremium:      isPremium,
		LimitProfileID: input.LimitProfileID,
		Settings:       settings,
	}

	return r.UserService.CreateUser(ctx, params)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id uuid.UUID, input generated.UpdateUserInput) (*user.User, error) {
	// Parse telegram ID if provided
	var telegramID *int64
	if input.TelegramID != nil && *input.TelegramID != "" {
		var tid int64
		if _, err := fmt.Sscanf(*input.TelegramID, "%d", &tid); err != nil {
			return nil, fmt.Errorf("invalid telegram ID: %w", err)
		}
		telegramID = &tid
	}

	params := userService.UpdateUserParams{
		TelegramID:       telegramID,
		TelegramUsername: input.TelegramUsername,
		Email:            input.Email,
		FirstName:        input.FirstName,
		LastName:         input.LastName,
		LanguageCode:     input.LanguageCode,
		IsPremium:        input.IsPremium,
		LimitProfileID:   input.LimitProfileID,
	}

	return r.UserService.UpdateUser(ctx, id, params)
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.UserService.DeleteUser(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// BatchDeleteUsers is the resolver for the batchDeleteUsers field.
func (r *mutationResolver) BatchDeleteUsers(ctx context.Context, ids []uuid.UUID) (int, error) {
	return r.UserService.BatchDeleteUsers(ctx, ids)
}

// UpdateUserSettings is the resolver for the updateUserSettings field.
func (r *mutationResolver) UpdateUserSettings(ctx context.Context, userID uuid.UUID, input generated.UpdateUserSettingsInput) (*user.User, error) {
	params := userService.UpdateSettingsParams{
		DefaultAIProvider:   input.DefaultAIProvider,
		DefaultAIModel:      input.DefaultAIModel,
		RiskLevel:           input.RiskLevel,
		MaxPositions:        input.MaxPositions,
		MaxPortfolioRisk:    input.MaxPortfolioRisk,
		MaxDailyDrawdown:    input.MaxDailyDrawdown,
		MaxConsecutiveLoss:  input.MaxConsecutiveLoss,
		NotificationsOn:     input.NotificationsOn,
		DailyReportTime:     input.DailyReportTime,
		Timezone:            input.Timezone,
		CircuitBreakerOn:    input.CircuitBreakerOn,
		MaxPositionSizeUSD:  input.MaxPositionSizeUsd,
		MaxTotalExposureUSD: input.MaxTotalExposureUsd,
		MinPositionSizeUSD:  input.MinPositionSizeUsd,
		MaxLeverageMultiple: input.MaxLeverageMultiple,
		AllowedExchanges:    input.AllowedExchanges,
	}

	return r.UserService.UpdateSettings(ctx, userID, params)
}

// SetUserActive is the resolver for the setUserActive field.
func (r *mutationResolver) SetUserActive(ctx context.Context, userID uuid.UUID, isActive bool) (*user.User, error) {
	return r.UserService.SetActive(ctx, userID, isActive)
}

// SetUserPremium is the resolver for the setUserPremium field.
func (r *mutationResolver) SetUserPremium(ctx context.Context, userID uuid.UUID, isPremium bool) (*user.User, error) {
	return r.UserService.SetPremium(ctx, userID, isPremium)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*user.User, error) {
	return r.UserService.GetByID(ctx, id)
}

// UserByTelegramID is the resolver for the userByTelegramID field.
func (r *queryResolver) UserByTelegramID(ctx context.Context, telegramID string) (*user.User, error) {
	// Parse telegram ID from string to int64
	var tid int64
	if _, err := fmt.Sscanf(telegramID, "%d", &tid); err != nil {
		return nil, fmt.Errorf("invalid telegram ID: %w", err)
	}
	return r.UserService.GetByTelegramID(ctx, tid)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*user.User, error) {
	// For now, just get active users (admin feature can be enhanced later)
	return r.UserService.GetActiveUsers(ctx)
}

// UsersConnection is the resolver for the usersConnection field.
func (r *queryResolver) UsersConnection(ctx context.Context, first *int, after *string, last *int, before *string) (*generated.UserConnection, error) {
	// Get all active users (admin query)
	allUsers, err := r.UserService.GetActiveUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(allUsers)
	offset, limit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := offset + limit
	if end > totalCount {
		end = totalCount
	}
	if offset > totalCount {
		offset = totalCount
	}

	items := allUsers[offset:end]

	// Build relay connection
	conn, err := relay.NewConnection(items, totalCount, params, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection: %w", err)
	}

	// Convert to GraphQL types
	edges := make([]*generated.UserEdge, len(conn.Edges))
	for i, edge := range conn.Edges {
		edges[i] = &generated.UserEdge{
			Node:   edge.Node,
			Cursor: edge.Cursor,
		}
	}

	return &generated.UserConnection{
		Edges: edges,
		PageInfo: &generated.PageInfo{
			HasNextPage:     conn.PageInfo.HasNextPage,
			HasPreviousPage: conn.PageInfo.HasPreviousPage,
			StartCursor:     conn.PageInfo.StartCursor,
			EndCursor:       conn.PageInfo.EndCursor,
		},
		TotalCount: conn.TotalCount,
	}, nil
}

// TelegramID is the resolver for the telegramID field.
func (r *userResolver) TelegramID(ctx context.Context, obj *user.User) (*string, error) {
	if obj.TelegramID == nil || *obj.TelegramID == 0 {
		return nil, nil
	}
	tid := fmt.Sprintf("%d", *obj.TelegramID)
	return &tid, nil
}

// TelegramUsername is the resolver for the telegramUsername field.
func (r *userResolver) TelegramUsername(ctx context.Context, obj *user.User) (*string, error) {
	if obj.TelegramUsername == "" {
		return nil, nil
	}
	return &obj.TelegramUsername, nil
}

// FirstName is the resolver for the firstName field.
func (r *userResolver) FirstName(ctx context.Context, obj *user.User) (string, error) {
	return obj.FirstName, nil
}

// LastName is the resolver for the lastName field.
func (r *userResolver) LastName(ctx context.Context, obj *user.User) (string, error) {
	return obj.LastName, nil
}

// LanguageCode is the resolver for the languageCode field.
func (r *userResolver) LanguageCode(ctx context.Context, obj *user.User) (string, error) {
	return obj.LanguageCode, nil
}

// IsActive is the resolver for the isActive field.
func (r *userResolver) IsActive(ctx context.Context, obj *user.User) (bool, error) {
	return obj.IsActive, nil
}

// IsPremium is the resolver for the isPremium field.
func (r *userResolver) IsPremium(ctx context.Context, obj *user.User) (bool, error) {
	return obj.IsPremium, nil
}

// LimitProfileID is the resolver for the limitProfileID field.
func (r *userResolver) LimitProfileID(ctx context.Context, obj *user.User) (*uuid.UUID, error) {
	return obj.LimitProfileID, nil
}

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) DeleteManyUsers(ctx context.Context, ids []uuid.UUID) (int, error) {
	return r.UserService.DeleteManyUsers(ctx, ids)
}
*/
