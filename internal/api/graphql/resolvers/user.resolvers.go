package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/user"
	userService "prometheus/internal/services/user"
	"prometheus/pkg/relay"

	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*user.User, error) {
	// Parse telegram ID if provided
	var telegramID *int64
	if input.TelegramID != nil && *input.TelegramID != "" {
		var tid int64
		if _, err := fmt.Sscanf(*input.TelegramID, "%d", &tid); err != nil {
			return nil, fmt.Errorf("invalid telegram ID: %w", err)
		}
		telegramID = &tid
	}

	// Parse settings if provided
	var settings *user.Settings
	if input.Settings != nil {
		s := user.DefaultSettings()
		if input.Settings.DefaultAIProvider != nil {
			s.DefaultAIProvider = *input.Settings.DefaultAIProvider
		}
		if input.Settings.DefaultAIModel != nil {
			s.DefaultAIModel = *input.Settings.DefaultAIModel
		}
		if input.Settings.RiskLevel != nil {
			s.RiskLevel = *input.Settings.RiskLevel
		}
		if input.Settings.MaxPositions != nil {
			s.MaxPositions = *input.Settings.MaxPositions
		}
		if input.Settings.MaxPortfolioRisk != nil {
			s.MaxPortfolioRisk = *input.Settings.MaxPortfolioRisk
		}
		if input.Settings.MaxDailyDrawdown != nil {
			s.MaxDailyDrawdown = *input.Settings.MaxDailyDrawdown
		}
		if input.Settings.MaxConsecutiveLoss != nil {
			s.MaxConsecutiveLoss = *input.Settings.MaxConsecutiveLoss
		}
		if input.Settings.NotificationsOn != nil {
			s.NotificationsOn = *input.Settings.NotificationsOn
		}
		if input.Settings.DailyReportTime != nil {
			s.DailyReportTime = *input.Settings.DailyReportTime
		}
		if input.Settings.Timezone != nil {
			s.Timezone = *input.Settings.Timezone
		}
		if input.Settings.CircuitBreakerOn != nil {
			s.CircuitBreakerOn = *input.Settings.CircuitBreakerOn
		}
		if input.Settings.MaxPositionSizeUsd != nil {
			s.MaxPositionSizeUSD = *input.Settings.MaxPositionSizeUsd
		}
		if input.Settings.MaxTotalExposureUsd != nil {
			s.MaxTotalExposureUSD = *input.Settings.MaxTotalExposureUsd
		}
		if input.Settings.MinPositionSizeUsd != nil {
			s.MinPositionSizeUSD = *input.Settings.MinPositionSizeUsd
		}
		if input.Settings.MaxLeverageMultiple != nil {
			s.MaxLeverageMultiple = *input.Settings.MaxLeverageMultiple
		}
		if input.Settings.AllowedExchanges != nil {
			s.AllowedExchanges = input.Settings.AllowedExchanges
		}
		settings = &s
	}

	// Set defaults
	isActive := true
	if input.IsActive != nil {
		isActive = *input.IsActive
	}
	isPremium := false
	if input.IsPremium != nil {
		isPremium = *input.IsPremium
	}

	params := userService.CreateUserParams{
		TelegramID: telegramID,
		TelegramUsername: func() string {
			if input.TelegramUsername == nil {
				return ""
			}
			return *input.TelegramUsername
		}(),
		Email:          input.Email,
		PasswordHash:   input.PasswordHash,
		FirstName:      input.FirstName,
		LastName:       input.LastName,
		LanguageCode:   input.LanguageCode,
		IsActive:       isActive,
		IsPremium:      isPremium,
		LimitProfileID: input.LimitProfileID,
		Settings:       settings,
	}

	return r.UserService.CreateUser(ctx, params)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id uuid.UUID, input generated.UpdateUserInput) (*user.User, error) {
	// Parse telegram ID if provided
	var telegramID *int64
	if input.TelegramID != nil && *input.TelegramID != "" {
		var tid int64
		if _, err := fmt.Sscanf(*input.TelegramID, "%d", &tid); err != nil {
			return nil, fmt.Errorf("invalid telegram ID: %w", err)
		}
		telegramID = &tid
	}

	params := userService.UpdateUserParams{
		TelegramID:       telegramID,
		TelegramUsername: input.TelegramUsername,
		Email:            input.Email,
		FirstName:        input.FirstName,
		LastName:         input.LastName,
		LanguageCode:     input.LanguageCode,
		IsPremium:        input.IsPremium,
		LimitProfileID:   input.LimitProfileID,
	}

	return r.UserService.UpdateUser(ctx, id, params)
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id uuid.UUID) (bool, error) {
	if err := r.UserService.DeleteUser(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// BatchDeleteUsers is the resolver for the batchDeleteUsers field.
func (r *mutationResolver) BatchDeleteUsers(ctx context.Context, ids []uuid.UUID) (int, error) {
	return r.UserService.BatchDeleteUsers(ctx, ids)
}

// UpdateUserSettings is the resolver for the updateUserSettings field.
func (r *mutationResolver) UpdateUserSettings(ctx context.Context, userID uuid.UUID, input generated.UpdateUserSettingsInput) (*user.User, error) {
	params := userService.UpdateSettingsParams{
		DefaultAIProvider:   input.DefaultAIProvider,
		DefaultAIModel:      input.DefaultAIModel,
		RiskLevel:           input.RiskLevel,
		MaxPositions:        input.MaxPositions,
		MaxPortfolioRisk:    input.MaxPortfolioRisk,
		MaxDailyDrawdown:    input.MaxDailyDrawdown,
		MaxConsecutiveLoss:  input.MaxConsecutiveLoss,
		NotificationsOn:     input.NotificationsOn,
		DailyReportTime:     input.DailyReportTime,
		Timezone:            input.Timezone,
		CircuitBreakerOn:    input.CircuitBreakerOn,
		MaxPositionSizeUSD:  input.MaxPositionSizeUsd,
		MaxTotalExposureUSD: input.MaxTotalExposureUsd,
		MinPositionSizeUSD:  input.MinPositionSizeUsd,
		MaxLeverageMultiple: input.MaxLeverageMultiple,
		AllowedExchanges:    input.AllowedExchanges,
	}

	return r.UserService.UpdateSettings(ctx, userID, params)
}

// SetUserActive is the resolver for the setUserActive field.
func (r *mutationResolver) SetUserActive(ctx context.Context, userID uuid.UUID, isActive bool) (*user.User, error) {
	return r.UserService.SetActive(ctx, userID, isActive)
}

// SetUserPremium is the resolver for the setUserPremium field.
func (r *mutationResolver) SetUserPremium(ctx context.Context, userID uuid.UUID, isPremium bool) (*user.User, error) {
	return r.UserService.SetPremium(ctx, userID, isPremium)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*user.User, error) {
	return r.UserService.GetByID(ctx, id)
}

// UserByTelegramID is the resolver for the userByTelegramID field.
func (r *queryResolver) UserByTelegramID(ctx context.Context, telegramID string) (*user.User, error) {
	// Parse telegram ID from string to int64
	var tid int64
	if _, err := fmt.Sscanf(telegramID, "%d", &tid); err != nil {
		return nil, fmt.Errorf("invalid telegram ID: %w", err)
	}
	return r.UserService.GetByTelegramID(ctx, tid)
}

// UsersConnection is the resolver for the usersConnection field.
func (r *queryResolver) UsersConnection(ctx context.Context, scope *string, search *string, filters map[string]any, first *int, after *string, last *int, before *string) (*generated.UserConnection, error) {
	// Use default scope if not provided
	effectiveScope := scope
	if effectiveScope == nil {
		defaultScope := "all"
		effectiveScope = &defaultScope
	}

	// Get filtered users from service (uses SQL WHERE, not in-memory filtering)
	filtered, err := r.UserService.GetUsersWithScope(ctx, effectiveScope, search, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	// Get scope counts from service (uses SQL GROUP BY)
	scopeCounts, err := r.UserService.GetUsersScopes(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get scope counts: %w", err)
	}

	// Apply pagination
	params := relay.PaginationParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("invalid pagination params: %w", err)
	}

	totalCount := len(filtered)
	offset, limit, err := relay.CalculateOffsetLimit(params, totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to calculate pagination: %w", err)
	}

	// Apply offset and limit
	end := offset + limit
	if end > totalCount {
		end = totalCount
	}
	if offset > totalCount {
		offset = totalCount
	}

	items := filtered[offset:end]

	// Build connection with scopes and filters using helper
	return buildUserConnection(items, totalCount, params, offset, scopeCounts)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, scope *string, search *string, filters map[string]any, first *int, after *string, last *int, before *string) (*generated.UserConnection, error) {
	// Delegate to UsersConnection method (same implementation)
	return r.UsersConnection(ctx, scope, search, filters, first, after, last, before)
}

// TelegramID is the resolver for the telegramID field.
func (r *userResolver) TelegramID(ctx context.Context, obj *user.User) (*string, error) {
	if obj.TelegramID == nil || *obj.TelegramID == 0 {
		return nil, nil
	}
	tid := fmt.Sprintf("%d", *obj.TelegramID)
	return &tid, nil
}

// TelegramUsername is the resolver for the telegramUsername field.
func (r *userResolver) TelegramUsername(ctx context.Context, obj *user.User) (*string, error) {
	if obj.TelegramUsername == "" {
		return nil, nil
	}
	return &obj.TelegramUsername, nil
}

// FirstName is the resolver for the firstName field.
func (r *userResolver) FirstName(ctx context.Context, obj *user.User) (string, error) {
	return obj.FirstName, nil
}

// LastName is the resolver for the lastName field.
func (r *userResolver) LastName(ctx context.Context, obj *user.User) (string, error) {
	return obj.LastName, nil
}

// LanguageCode is the resolver for the languageCode field.
func (r *userResolver) LanguageCode(ctx context.Context, obj *user.User) (string, error) {
	return obj.LanguageCode, nil
}

// IsActive is the resolver for the isActive field.
func (r *userResolver) IsActive(ctx context.Context, obj *user.User) (bool, error) {
	return obj.IsActive, nil
}

// IsPremium is the resolver for the isPremium field.
func (r *userResolver) IsPremium(ctx context.Context, obj *user.User) (bool, error) {
	return obj.IsPremium, nil
}

// LimitProfileID is the resolver for the limitProfileID field.
func (r *userResolver) LimitProfileID(ctx context.Context, obj *user.User) (*uuid.UUID, error) {
	return obj.LimitProfileID, nil
}

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
