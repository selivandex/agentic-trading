package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"prometheus/internal/api/graphql/generated"
	"prometheus/internal/domain/user"

	"github.com/google/uuid"
)

// UpdateUserSettings is the resolver for the updateUserSettings field.
func (r *mutationResolver) UpdateUserSettings(ctx context.Context, userID uuid.UUID, input generated.UpdateUserSettingsInput) (*user.User, error) {
	// Get existing user via service
	u, err := r.UserService.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	// Update settings fields if provided
	if input.DefaultAIProvider != nil {
		u.Settings.DefaultAIProvider = *input.DefaultAIProvider
	}
	if input.DefaultAIModel != nil {
		u.Settings.DefaultAIModel = *input.DefaultAIModel
	}
	if input.RiskLevel != nil {
		u.Settings.RiskLevel = *input.RiskLevel
	}
	if input.MaxPositions != nil {
		u.Settings.MaxPositions = *input.MaxPositions
	}
	if input.MaxPortfolioRisk != nil {
		u.Settings.MaxPortfolioRisk = *input.MaxPortfolioRisk
	}
	if input.MaxDailyDrawdown != nil {
		u.Settings.MaxDailyDrawdown = *input.MaxDailyDrawdown
	}
	if input.MaxConsecutiveLoss != nil {
		u.Settings.MaxConsecutiveLoss = *input.MaxConsecutiveLoss
	}
	if input.NotificationsOn != nil {
		u.Settings.NotificationsOn = *input.NotificationsOn
	}
	if input.DailyReportTime != nil {
		u.Settings.DailyReportTime = *input.DailyReportTime
	}
	if input.Timezone != nil {
		u.Settings.Timezone = *input.Timezone
	}
	if input.CircuitBreakerOn != nil {
		u.Settings.CircuitBreakerOn = *input.CircuitBreakerOn
	}
	if input.MaxPositionSizeUsd != nil {
		u.Settings.MaxPositionSizeUSD = *input.MaxPositionSizeUsd
	}
	if input.MaxTotalExposureUsd != nil {
		u.Settings.MaxTotalExposureUSD = *input.MaxTotalExposureUsd
	}
	if input.MinPositionSizeUsd != nil {
		u.Settings.MinPositionSizeUSD = *input.MinPositionSizeUsd
	}
	if input.MaxLeverageMultiple != nil {
		u.Settings.MaxLeverageMultiple = *input.MaxLeverageMultiple
	}
	if input.AllowedExchanges != nil {
		u.Settings.AllowedExchanges = input.AllowedExchanges
	}

	// Use service to update (with events)
	if err := r.UserService.Update(ctx, u); err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	return u, nil
}

// SetUserActive is the resolver for the setUserActive field.
func (r *mutationResolver) SetUserActive(ctx context.Context, userID uuid.UUID, isActive bool) (*user.User, error) {
	// Use service method (publishes events)
	if err := r.UserService.SetActive(ctx, userID, isActive); err != nil {
		return nil, fmt.Errorf("failed to set user active: %w", err)
	}

	// Fetch updated user
	return r.UserService.GetByID(ctx, userID)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*user.User, error) {
	return r.UserService.GetByID(ctx, id)
}

// UserByTelegramID is the resolver for the userByTelegramID field.
func (r *queryResolver) UserByTelegramID(ctx context.Context, telegramID string) (*user.User, error) {
	// Parse telegram ID from string to int64
	var tid int64
	if _, err := fmt.Sscanf(telegramID, "%d", &tid); err != nil {
		return nil, fmt.Errorf("invalid telegram ID: %w", err)
	}
	return r.UserService.GetByTelegramID(ctx, tid)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*user.User, error) {
	// For now, just get active users (admin feature can be enhanced later)
	return r.UserService.GetActiveUsers(ctx)
}

// TelegramID is the resolver for the telegramID field.
func (r *userResolver) TelegramID(ctx context.Context, obj *user.User) (string, error) {
	return fmt.Sprintf("%d", obj.TelegramID), nil
}

// TelegramUsername is the resolver for the telegramUsername field.
func (r *userResolver) TelegramUsername(ctx context.Context, obj *user.User) (string, error) {
	return obj.TelegramUsername, nil
}

// FirstName is the resolver for the firstName field.
func (r *userResolver) FirstName(ctx context.Context, obj *user.User) (string, error) {
	return obj.FirstName, nil
}

// LastName is the resolver for the lastName field.
func (r *userResolver) LastName(ctx context.Context, obj *user.User) (string, error) {
	return obj.LastName, nil
}

// LanguageCode is the resolver for the languageCode field.
func (r *userResolver) LanguageCode(ctx context.Context, obj *user.User) (string, error) {
	return obj.LanguageCode, nil
}

// IsActive is the resolver for the isActive field.
func (r *userResolver) IsActive(ctx context.Context, obj *user.User) (bool, error) {
	return obj.IsActive, nil
}

// IsPremium is the resolver for the isPremium field.
func (r *userResolver) IsPremium(ctx context.Context, obj *user.User) (bool, error) {
	return obj.IsPremium, nil
}

// LimitProfileID is the resolver for the limitProfileID field.
func (r *userResolver) LimitProfileID(ctx context.Context, obj *user.User) (*uuid.UUID, error) {
	return obj.LimitProfileID, nil
}

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
