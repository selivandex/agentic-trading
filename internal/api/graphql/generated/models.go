// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"fmt"
	"io"
	"prometheus/internal/domain/agent"
	"prometheus/internal/domain/fundwatchlist"
	"prometheus/internal/domain/strategy"
	"prometheus/internal/domain/user"
	"strconv"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

// Connection type for Agent collection
type AgentConnection struct {
	// A list of edges
	Edges []*AgentEdge `json:"edges"`
	// Information to aid in pagination
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of items (if available)
	TotalCount int `json:"totalCount"`
	// Available filter scopes with counts
	Scopes []*Scope `json:"scopes"`
	// Available dynamic filters
	Filters []*Filter `json:"filters"`
}

// Edge type for Agent
type AgentEdge struct {
	// The item at the end of the edge
	Node *agent.Agent `json:"node"`
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
}

type AuthResponse struct {
	Token string     `json:"token"`
	User  *user.User `json:"user"`
}

// Common input arguments for backward pagination
type BackwardPaginationInput struct {
	// Returns the last n elements from the list
	Last int `json:"last"`
	// Returns the elements in the list that come before the specified cursor
	Before *string `json:"before,omitempty"`
}

type CreateAgentInput struct {
	Identifier     *string        `json:"identifier,omitempty"`
	Name           *string        `json:"name,omitempty"`
	Description    *string        `json:"description,omitempty"`
	Category       *string        `json:"category,omitempty"`
	SystemPrompt   *string        `json:"systemPrompt,omitempty"`
	Instructions   *string        `json:"instructions,omitempty"`
	ModelProvider  *string        `json:"modelProvider,omitempty"`
	ModelName      *string        `json:"modelName,omitempty"`
	Temperature    *float64       `json:"temperature,omitempty"`
	MaxTokens      *int           `json:"maxTokens,omitempty"`
	AvailableTools map[string]any `json:"availableTools,omitempty"`
	MaxCostPerRun  *float64       `json:"maxCostPerRun,omitempty"`
	TimeoutSeconds *int           `json:"timeoutSeconds,omitempty"`
	IsActive       *bool          `json:"isActive,omitempty"`
	Version        *int           `json:"version,omitempty"`
}

type CreateFundWatchlistInput struct {
	Symbol     string `json:"symbol"`
	MarketType string `json:"marketType"`
	Category   string `json:"category"`
	Tier       int    `json:"tier"`
}

type CreateStrategyInput struct {
	Name               string                      `json:"name"`
	Description        string                      `json:"description"`
	AllocatedCapital   decimal.Decimal             `json:"allocatedCapital"`
	MarketType         strategy.MarketType         `json:"marketType"`
	RiskTolerance      strategy.RiskTolerance      `json:"riskTolerance"`
	RebalanceFrequency strategy.RebalanceFrequency `json:"rebalanceFrequency"`
	TargetAllocations  map[string]any              `json:"targetAllocations,omitempty"`
}

type CreateUserInput struct {
	TelegramID       *string        `json:"telegramID,omitempty"`
	TelegramUsername *string        `json:"telegramUsername,omitempty"`
	Email            *string        `json:"email,omitempty"`
	PasswordHash     *string        `json:"passwordHash,omitempty"`
	FirstName        string         `json:"firstName"`
	LastName         string         `json:"lastName"`
	LanguageCode     string         `json:"languageCode"`
	IsActive         *bool          `json:"isActive,omitempty"`
	IsPremium        *bool          `json:"isPremium,omitempty"`
	LimitProfileID   *uuid.UUID     `json:"limitProfileID,omitempty"`
	Settings         *SettingsInput `json:"settings,omitempty"`
}

// Filter represents a dynamic filter definition
type Filter struct {
	// Unique identifier for the filter
	ID string `json:"id"`
	// Human-readable name for the filter
	Name string `json:"name"`
	// Type of filter input
	Type FilterType `json:"type"`
	// Static options for select/multiselect filters
	// If optionsQuery is specified, this field should be null
	Options []*FilterOption `json:"options,omitempty"`
	// GraphQL query name to fetch dynamic options
	// Example: "users" will call users query to get list of users
	OptionsQuery *string `json:"optionsQuery,omitempty"`
	// Arguments to pass to optionsQuery (JSON)
	// Example: {"role": "ADMIN"}
	OptionsQueryArgs map[string]any `json:"optionsQueryArgs,omitempty"`
	// Default value (optional)
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Placeholder text (optional)
	Placeholder *string `json:"placeholder,omitempty"`
	// Minimum value for NUMBER/NUMBER_RANGE filters (optional)
	// Computed from database for dynamic ranges
	Min *float64 `json:"min,omitempty"`
	// Maximum value for NUMBER/NUMBER_RANGE filters (optional)
	// Computed from database for dynamic ranges
	Max *float64 `json:"max,omitempty"`
}

// FilterOption represents an option for select/multiselect filters
type FilterOption struct {
	// Value of the option
	Value string `json:"value"`
	// Display label for the option
	Label string `json:"label"`
}

// Common input arguments for forward pagination
type ForwardPaginationInput struct {
	// Returns the first n elements from the list
	First int `json:"first"`
	// Returns the elements in the list that come after the specified cursor
	After *string `json:"after,omitempty"`
}

// Connection type for FundWatchlist collection
type FundWatchlistConnection struct {
	// A list of edges
	Edges []*FundWatchlistEdge `json:"edges"`
	// Information to aid in pagination
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of items (if available)
	TotalCount int `json:"totalCount"`
	// Available filter scopes with counts
	Scopes []*Scope `json:"scopes"`
	// Available dynamic filters
	Filters []*Filter `json:"filters"`
}

// Edge type for FundWatchlist
type FundWatchlistEdge struct {
	// The item at the end of the edge
	Node *fundwatchlist.Watchlist `json:"node"`
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Mutation struct {
}

// PageInfo contains information about pagination in a connection
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating forwards, the cursor to continue
	EndCursor *string `json:"endCursor,omitempty"`
	// When paginating backwards, the cursor to continue
	StartCursor *string `json:"startCursor,omitempty"`
}

type Query struct {
}

type RegisterInput struct {
	Email     string `json:"email"`
	Password  string `json:"password"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

// Scope represents a filter/tab with item count
type Scope struct {
	// Unique identifier for the scope
	ID string `json:"id"`
	// Human-readable name for the scope
	Name string `json:"name"`
	// Number of items that match this scope
	Count int `json:"count"`
}

type SettingsInput struct {
	DefaultAIProvider   *string  `json:"defaultAIProvider,omitempty"`
	DefaultAIModel      *string  `json:"defaultAIModel,omitempty"`
	RiskLevel           *string  `json:"riskLevel,omitempty"`
	MaxPositions        *int     `json:"maxPositions,omitempty"`
	MaxPortfolioRisk    *float64 `json:"maxPortfolioRisk,omitempty"`
	MaxDailyDrawdown    *float64 `json:"maxDailyDrawdown,omitempty"`
	MaxConsecutiveLoss  *int     `json:"maxConsecutiveLoss,omitempty"`
	NotificationsOn     *bool    `json:"notificationsOn,omitempty"`
	DailyReportTime     *string  `json:"dailyReportTime,omitempty"`
	Timezone            *string  `json:"timezone,omitempty"`
	CircuitBreakerOn    *bool    `json:"circuitBreakerOn,omitempty"`
	MaxPositionSizeUsd  *float64 `json:"maxPositionSizeUSD,omitempty"`
	MaxTotalExposureUsd *float64 `json:"maxTotalExposureUSD,omitempty"`
	MinPositionSizeUsd  *float64 `json:"minPositionSizeUSD,omitempty"`
	MaxLeverageMultiple *float64 `json:"maxLeverageMultiple,omitempty"`
	AllowedExchanges    []string `json:"allowedExchanges,omitempty"`
}

// Connection type for Strategy collection
type StrategyConnection struct {
	// A list of edges
	Edges []*StrategyEdge `json:"edges"`
	// Information to aid in pagination
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of items (if available)
	TotalCount int `json:"totalCount"`
	// Available filter scopes with counts
	Scopes []*Scope `json:"scopes"`
	// Available dynamic filters
	Filters []*Filter `json:"filters"`
}

// Edge type for Strategy
type StrategyEdge struct {
	// The item at the end of the edge
	Node *strategy.Strategy `json:"node"`
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
}

type Subscription struct {
}

type UpdateAgentInput struct {
	Identifier     *string        `json:"identifier,omitempty"`
	Name           *string        `json:"name,omitempty"`
	Description    *string        `json:"description,omitempty"`
	Category       *string        `json:"category,omitempty"`
	SystemPrompt   *string        `json:"systemPrompt,omitempty"`
	Instructions   *string        `json:"instructions,omitempty"`
	ModelProvider  *string        `json:"modelProvider,omitempty"`
	ModelName      *string        `json:"modelName,omitempty"`
	Temperature    *float64       `json:"temperature,omitempty"`
	MaxTokens      *int           `json:"maxTokens,omitempty"`
	AvailableTools map[string]any `json:"availableTools,omitempty"`
	MaxCostPerRun  *float64       `json:"maxCostPerRun,omitempty"`
	TimeoutSeconds *int           `json:"timeoutSeconds,omitempty"`
	IsActive       *bool          `json:"isActive,omitempty"`
	Version        *int           `json:"version,omitempty"`
}

type UpdateFundWatchlistInput struct {
	Category     *string `json:"category,omitempty"`
	Tier         *int    `json:"tier,omitempty"`
	IsActive     *bool   `json:"isActive,omitempty"`
	IsPaused     *bool   `json:"isPaused,omitempty"`
	PausedReason *string `json:"pausedReason,omitempty"`
}

type UpdateStrategyInput struct {
	Name               *string                      `json:"name,omitempty"`
	Description        *string                      `json:"description,omitempty"`
	RiskTolerance      *strategy.RiskTolerance      `json:"riskTolerance,omitempty"`
	RebalanceFrequency *strategy.RebalanceFrequency `json:"rebalanceFrequency,omitempty"`
	TargetAllocations  map[string]any               `json:"targetAllocations,omitempty"`
}

type UpdateUserInput struct {
	TelegramID       *string    `json:"telegramID,omitempty"`
	TelegramUsername *string    `json:"telegramUsername,omitempty"`
	Email            *string    `json:"email,omitempty"`
	FirstName        *string    `json:"firstName,omitempty"`
	LastName         *string    `json:"lastName,omitempty"`
	LanguageCode     *string    `json:"languageCode,omitempty"`
	IsPremium        *bool      `json:"isPremium,omitempty"`
	LimitProfileID   *uuid.UUID `json:"limitProfileID,omitempty"`
}

type UpdateUserSettingsInput struct {
	DefaultAIProvider   *string  `json:"defaultAIProvider,omitempty"`
	DefaultAIModel      *string  `json:"defaultAIModel,omitempty"`
	RiskLevel           *string  `json:"riskLevel,omitempty"`
	MaxPositions        *int     `json:"maxPositions,omitempty"`
	MaxPortfolioRisk    *float64 `json:"maxPortfolioRisk,omitempty"`
	MaxDailyDrawdown    *float64 `json:"maxDailyDrawdown,omitempty"`
	MaxConsecutiveLoss  *int     `json:"maxConsecutiveLoss,omitempty"`
	NotificationsOn     *bool    `json:"notificationsOn,omitempty"`
	DailyReportTime     *string  `json:"dailyReportTime,omitempty"`
	Timezone            *string  `json:"timezone,omitempty"`
	CircuitBreakerOn    *bool    `json:"circuitBreakerOn,omitempty"`
	MaxPositionSizeUsd  *float64 `json:"maxPositionSizeUSD,omitempty"`
	MaxTotalExposureUsd *float64 `json:"maxTotalExposureUSD,omitempty"`
	MinPositionSizeUsd  *float64 `json:"minPositionSizeUSD,omitempty"`
	MaxLeverageMultiple *float64 `json:"maxLeverageMultiple,omitempty"`
	AllowedExchanges    []string `json:"allowedExchanges,omitempty"`
}

// Connection type for User collection
type UserConnection struct {
	// A list of edges
	Edges []*UserEdge `json:"edges"`
	// Information to aid in pagination
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of items (if available)
	TotalCount int `json:"totalCount"`
	// Available filter scopes with counts
	Scopes []*Scope `json:"scopes"`
	// Available dynamic filters
	Filters []*Filter `json:"filters"`
}

// Edge type for User
type UserEdge struct {
	// The item at the end of the edge
	Node *user.User `json:"node"`
	// A cursor for use in pagination
	Cursor string `json:"cursor"`
}

// FilterType represents the type of filter input
type FilterType string

const (
	FilterTypeText        FilterType = "TEXT"
	FilterTypeNumber      FilterType = "NUMBER"
	FilterTypeDate        FilterType = "DATE"
	FilterTypeSelect      FilterType = "SELECT"
	FilterTypeMultiselect FilterType = "MULTISELECT"
	FilterTypeBoolean     FilterType = "BOOLEAN"
	FilterTypeDateRange   FilterType = "DATE_RANGE"
	FilterTypeNumberRange FilterType = "NUMBER_RANGE"
)

var AllFilterType = []FilterType{
	FilterTypeText,
	FilterTypeNumber,
	FilterTypeDate,
	FilterTypeSelect,
	FilterTypeMultiselect,
	FilterTypeBoolean,
	FilterTypeDateRange,
	FilterTypeNumberRange,
}

func (e FilterType) IsValid() bool {
	switch e {
	case FilterTypeText, FilterTypeNumber, FilterTypeDate, FilterTypeSelect, FilterTypeMultiselect, FilterTypeBoolean, FilterTypeDateRange, FilterTypeNumberRange:
		return true
	}
	return false
}

func (e FilterType) String() string {
	return string(e)
}

func (e *FilterType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterType", str)
	}
	return nil
}

func (e FilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FilterType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FilterType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
