// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"prometheus/internal/domain/fundwatchlist"
	"prometheus/internal/domain/strategy"
	"prometheus/internal/domain/user"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	FundWatchlist() FundWatchlistResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Strategy() StrategyResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	FundWatchlist struct {
		Category       func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		IsActive       func(childComplexity int) int
		IsPaused       func(childComplexity int) int
		LastAnalyzedAt func(childComplexity int) int
		MarketType     func(childComplexity int) int
		PausedReason   func(childComplexity int) int
		Symbol         func(childComplexity int) int
		Tier           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	Mutation struct {
		CloseStrategy            func(childComplexity int, id uuid.UUID) int
		CreateFundWatchlist      func(childComplexity int, input CreateFundWatchlistInput) int
		CreateStrategy           func(childComplexity int, userID uuid.UUID, input CreateStrategyInput) int
		DeleteFundWatchlist      func(childComplexity int, id uuid.UUID) int
		Empty                    func(childComplexity int) int
		PauseStrategy            func(childComplexity int, id uuid.UUID) int
		ResumeStrategy           func(childComplexity int, id uuid.UUID) int
		SetUserActive            func(childComplexity int, userID uuid.UUID, isActive bool) int
		ToggleFundWatchlistPause func(childComplexity int, id uuid.UUID, isPaused bool, reason *string) int
		UpdateFundWatchlist      func(childComplexity int, id uuid.UUID, input UpdateFundWatchlistInput) int
		UpdateStrategy           func(childComplexity int, id uuid.UUID, input UpdateStrategyInput) int
		UpdateUserSettings       func(childComplexity int, userID uuid.UUID, input UpdateUserSettingsInput) int
	}

	Query struct {
		FundWatchlist         func(childComplexity int, id uuid.UUID) int
		FundWatchlistBySymbol func(childComplexity int, symbol string, marketType string) int
		FundWatchlists        func(childComplexity int, limit *int, offset *int, isActive *bool, category *string, tier *int) int
		Health                func(childComplexity int) int
		MonitoredSymbols      func(childComplexity int, marketType *string) int
		Strategies            func(childComplexity int, limit *int, offset *int, status *strategy.StrategyStatus) int
		Strategy              func(childComplexity int, id uuid.UUID) int
		User                  func(childComplexity int, id uuid.UUID) int
		UserByTelegramID      func(childComplexity int, telegramID string) int
		UserStrategies        func(childComplexity int, userID uuid.UUID, status *strategy.StrategyStatus) int
		Users                 func(childComplexity int, limit *int, offset *int) int
	}

	Settings struct {
		AllowedExchanges    func(childComplexity int) int
		CircuitBreakerOn    func(childComplexity int) int
		DailyReportTime     func(childComplexity int) int
		DefaultAIModel      func(childComplexity int) int
		DefaultAIProvider   func(childComplexity int) int
		MaxConsecutiveLoss  func(childComplexity int) int
		MaxDailyDrawdown    func(childComplexity int) int
		MaxLeverageMultiple func(childComplexity int) int
		MaxPortfolioRisk    func(childComplexity int) int
		MaxPositionSizeUSD  func(childComplexity int) int
		MaxPositions        func(childComplexity int) int
		MaxTotalExposureUSD func(childComplexity int) int
		MinPositionSizeUSD  func(childComplexity int) int
		NotificationsOn     func(childComplexity int) int
		RiskLevel           func(childComplexity int) int
		Timezone            func(childComplexity int) int
	}

	Strategy struct {
		AllocatedCapital   func(childComplexity int) int
		CashReserve        func(childComplexity int) int
		ClosedAt           func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		CurrentEquity      func(childComplexity int) int
		Description        func(childComplexity int) int
		ID                 func(childComplexity int) int
		LastRebalancedAt   func(childComplexity int) int
		MarketType         func(childComplexity int) int
		MaxDrawdown        func(childComplexity int) int
		Name               func(childComplexity int) int
		ReasoningLog       func(childComplexity int) int
		RebalanceFrequency func(childComplexity int) int
		RiskTolerance      func(childComplexity int) int
		SharpeRatio        func(childComplexity int) int
		Status             func(childComplexity int) int
		TargetAllocations  func(childComplexity int) int
		TotalPnL           func(childComplexity int) int
		TotalPnLPercent    func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
		User               func(childComplexity int) int
		UserID             func(childComplexity int) int
		WinRate            func(childComplexity int) int
	}

	Subscription struct {
		Empty func(childComplexity int) int
	}

	User struct {
		CreatedAt        func(childComplexity int) int
		FirstName        func(childComplexity int) int
		ID               func(childComplexity int) int
		IsActive         func(childComplexity int) int
		IsPremium        func(childComplexity int) int
		LanguageCode     func(childComplexity int) int
		LastName         func(childComplexity int) int
		LimitProfileID   func(childComplexity int) int
		Settings         func(childComplexity int) int
		TelegramID       func(childComplexity int) int
		TelegramUsername func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}
}

type FundWatchlistResolver interface {
	MarketType(ctx context.Context, obj *fundwatchlist.Watchlist) (string, error)
}
type MutationResolver interface {
	Empty(ctx context.Context) (*string, error)
	CreateFundWatchlist(ctx context.Context, input CreateFundWatchlistInput) (*fundwatchlist.Watchlist, error)
	UpdateFundWatchlist(ctx context.Context, id uuid.UUID, input UpdateFundWatchlistInput) (*fundwatchlist.Watchlist, error)
	DeleteFundWatchlist(ctx context.Context, id uuid.UUID) (bool, error)
	ToggleFundWatchlistPause(ctx context.Context, id uuid.UUID, isPaused bool, reason *string) (*fundwatchlist.Watchlist, error)
	CreateStrategy(ctx context.Context, userID uuid.UUID, input CreateStrategyInput) (*strategy.Strategy, error)
	UpdateStrategy(ctx context.Context, id uuid.UUID, input UpdateStrategyInput) (*strategy.Strategy, error)
	PauseStrategy(ctx context.Context, id uuid.UUID) (*strategy.Strategy, error)
	ResumeStrategy(ctx context.Context, id uuid.UUID) (*strategy.Strategy, error)
	CloseStrategy(ctx context.Context, id uuid.UUID) (*strategy.Strategy, error)
	UpdateUserSettings(ctx context.Context, userID uuid.UUID, input UpdateUserSettingsInput) (*user.User, error)
	SetUserActive(ctx context.Context, userID uuid.UUID, isActive bool) (*user.User, error)
}
type QueryResolver interface {
	Health(ctx context.Context) (string, error)
	FundWatchlist(ctx context.Context, id uuid.UUID) (*fundwatchlist.Watchlist, error)
	FundWatchlistBySymbol(ctx context.Context, symbol string, marketType string) (*fundwatchlist.Watchlist, error)
	FundWatchlists(ctx context.Context, limit *int, offset *int, isActive *bool, category *string, tier *int) ([]*fundwatchlist.Watchlist, error)
	MonitoredSymbols(ctx context.Context, marketType *string) ([]*fundwatchlist.Watchlist, error)
	Strategy(ctx context.Context, id uuid.UUID) (*strategy.Strategy, error)
	UserStrategies(ctx context.Context, userID uuid.UUID, status *strategy.StrategyStatus) ([]*strategy.Strategy, error)
	Strategies(ctx context.Context, limit *int, offset *int, status *strategy.StrategyStatus) ([]*strategy.Strategy, error)
	User(ctx context.Context, id uuid.UUID) (*user.User, error)
	UserByTelegramID(ctx context.Context, telegramID string) (*user.User, error)
	Users(ctx context.Context, limit *int, offset *int) ([]*user.User, error)
}
type StrategyResolver interface {
	UserID(ctx context.Context, obj *strategy.Strategy) (uuid.UUID, error)
	User(ctx context.Context, obj *strategy.Strategy) (*user.User, error)

	TargetAllocations(ctx context.Context, obj *strategy.Strategy) (map[string]any, error)

	ReasoningLog(ctx context.Context, obj *strategy.Strategy) (map[string]any, error)
}
type SubscriptionResolver interface {
	Empty(ctx context.Context) (<-chan *string, error)
}
type UserResolver interface {
	TelegramID(ctx context.Context, obj *user.User) (string, error)
	TelegramUsername(ctx context.Context, obj *user.User) (string, error)
	FirstName(ctx context.Context, obj *user.User) (string, error)
	LastName(ctx context.Context, obj *user.User) (string, error)
	LanguageCode(ctx context.Context, obj *user.User) (string, error)
	IsActive(ctx context.Context, obj *user.User) (bool, error)
	IsPremium(ctx context.Context, obj *user.User) (bool, error)
	LimitProfileID(ctx context.Context, obj *user.User) (*uuid.UUID, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "FundWatchlist.category":
		if e.complexity.FundWatchlist.Category == nil {
			break
		}

		return e.complexity.FundWatchlist.Category(childComplexity), true
	case "FundWatchlist.createdAt":
		if e.complexity.FundWatchlist.CreatedAt == nil {
			break
		}

		return e.complexity.FundWatchlist.CreatedAt(childComplexity), true
	case "FundWatchlist.id":
		if e.complexity.FundWatchlist.ID == nil {
			break
		}

		return e.complexity.FundWatchlist.ID(childComplexity), true
	case "FundWatchlist.isActive":
		if e.complexity.FundWatchlist.IsActive == nil {
			break
		}

		return e.complexity.FundWatchlist.IsActive(childComplexity), true
	case "FundWatchlist.isPaused":
		if e.complexity.FundWatchlist.IsPaused == nil {
			break
		}

		return e.complexity.FundWatchlist.IsPaused(childComplexity), true
	case "FundWatchlist.lastAnalyzedAt":
		if e.complexity.FundWatchlist.LastAnalyzedAt == nil {
			break
		}

		return e.complexity.FundWatchlist.LastAnalyzedAt(childComplexity), true
	case "FundWatchlist.marketType":
		if e.complexity.FundWatchlist.MarketType == nil {
			break
		}

		return e.complexity.FundWatchlist.MarketType(childComplexity), true
	case "FundWatchlist.pausedReason":
		if e.complexity.FundWatchlist.PausedReason == nil {
			break
		}

		return e.complexity.FundWatchlist.PausedReason(childComplexity), true
	case "FundWatchlist.symbol":
		if e.complexity.FundWatchlist.Symbol == nil {
			break
		}

		return e.complexity.FundWatchlist.Symbol(childComplexity), true
	case "FundWatchlist.tier":
		if e.complexity.FundWatchlist.Tier == nil {
			break
		}

		return e.complexity.FundWatchlist.Tier(childComplexity), true
	case "FundWatchlist.updatedAt":
		if e.complexity.FundWatchlist.UpdatedAt == nil {
			break
		}

		return e.complexity.FundWatchlist.UpdatedAt(childComplexity), true

	case "Mutation.closeStrategy":
		if e.complexity.Mutation.CloseStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_closeStrategy_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CloseStrategy(childComplexity, args["id"].(uuid.UUID)), true
	case "Mutation.createFundWatchlist":
		if e.complexity.Mutation.CreateFundWatchlist == nil {
			break
		}

		args, err := ec.field_Mutation_createFundWatchlist_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFundWatchlist(childComplexity, args["input"].(CreateFundWatchlistInput)), true
	case "Mutation.createStrategy":
		if e.complexity.Mutation.CreateStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_createStrategy_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateStrategy(childComplexity, args["userID"].(uuid.UUID), args["input"].(CreateStrategyInput)), true
	case "Mutation.deleteFundWatchlist":
		if e.complexity.Mutation.DeleteFundWatchlist == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFundWatchlist_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFundWatchlist(childComplexity, args["id"].(uuid.UUID)), true
	case "Mutation._empty":
		if e.complexity.Mutation.Empty == nil {
			break
		}

		return e.complexity.Mutation.Empty(childComplexity), true
	case "Mutation.pauseStrategy":
		if e.complexity.Mutation.PauseStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_pauseStrategy_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PauseStrategy(childComplexity, args["id"].(uuid.UUID)), true
	case "Mutation.resumeStrategy":
		if e.complexity.Mutation.ResumeStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_resumeStrategy_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResumeStrategy(childComplexity, args["id"].(uuid.UUID)), true
	case "Mutation.setUserActive":
		if e.complexity.Mutation.SetUserActive == nil {
			break
		}

		args, err := ec.field_Mutation_setUserActive_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetUserActive(childComplexity, args["userID"].(uuid.UUID), args["isActive"].(bool)), true
	case "Mutation.toggleFundWatchlistPause":
		if e.complexity.Mutation.ToggleFundWatchlistPause == nil {
			break
		}

		args, err := ec.field_Mutation_toggleFundWatchlistPause_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ToggleFundWatchlistPause(childComplexity, args["id"].(uuid.UUID), args["isPaused"].(bool), args["reason"].(*string)), true
	case "Mutation.updateFundWatchlist":
		if e.complexity.Mutation.UpdateFundWatchlist == nil {
			break
		}

		args, err := ec.field_Mutation_updateFundWatchlist_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFundWatchlist(childComplexity, args["id"].(uuid.UUID), args["input"].(UpdateFundWatchlistInput)), true
	case "Mutation.updateStrategy":
		if e.complexity.Mutation.UpdateStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_updateStrategy_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStrategy(childComplexity, args["id"].(uuid.UUID), args["input"].(UpdateStrategyInput)), true
	case "Mutation.updateUserSettings":
		if e.complexity.Mutation.UpdateUserSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserSettings(childComplexity, args["userID"].(uuid.UUID), args["input"].(UpdateUserSettingsInput)), true

	case "Query.fundWatchlist":
		if e.complexity.Query.FundWatchlist == nil {
			break
		}

		args, err := ec.field_Query_fundWatchlist_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FundWatchlist(childComplexity, args["id"].(uuid.UUID)), true
	case "Query.fundWatchlistBySymbol":
		if e.complexity.Query.FundWatchlistBySymbol == nil {
			break
		}

		args, err := ec.field_Query_fundWatchlistBySymbol_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FundWatchlistBySymbol(childComplexity, args["symbol"].(string), args["marketType"].(string)), true
	case "Query.fundWatchlists":
		if e.complexity.Query.FundWatchlists == nil {
			break
		}

		args, err := ec.field_Query_fundWatchlists_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FundWatchlists(childComplexity, args["limit"].(*int), args["offset"].(*int), args["isActive"].(*bool), args["category"].(*string), args["tier"].(*int)), true
	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true
	case "Query.monitoredSymbols":
		if e.complexity.Query.MonitoredSymbols == nil {
			break
		}

		args, err := ec.field_Query_monitoredSymbols_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MonitoredSymbols(childComplexity, args["marketType"].(*string)), true
	case "Query.strategies":
		if e.complexity.Query.Strategies == nil {
			break
		}

		args, err := ec.field_Query_strategies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Strategies(childComplexity, args["limit"].(*int), args["offset"].(*int), args["status"].(*strategy.StrategyStatus)), true
	case "Query.strategy":
		if e.complexity.Query.Strategy == nil {
			break
		}

		args, err := ec.field_Query_strategy_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Strategy(childComplexity, args["id"].(uuid.UUID)), true
	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(uuid.UUID)), true
	case "Query.userByTelegramID":
		if e.complexity.Query.UserByTelegramID == nil {
			break
		}

		args, err := ec.field_Query_userByTelegramID_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByTelegramID(childComplexity, args["telegramID"].(string)), true
	case "Query.userStrategies":
		if e.complexity.Query.UserStrategies == nil {
			break
		}

		args, err := ec.field_Query_userStrategies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserStrategies(childComplexity, args["userID"].(uuid.UUID), args["status"].(*strategy.StrategyStatus)), true
	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["limit"].(*int), args["offset"].(*int)), true

	case "Settings.allowedExchanges":
		if e.complexity.Settings.AllowedExchanges == nil {
			break
		}

		return e.complexity.Settings.AllowedExchanges(childComplexity), true
	case "Settings.circuitBreakerOn":
		if e.complexity.Settings.CircuitBreakerOn == nil {
			break
		}

		return e.complexity.Settings.CircuitBreakerOn(childComplexity), true
	case "Settings.dailyReportTime":
		if e.complexity.Settings.DailyReportTime == nil {
			break
		}

		return e.complexity.Settings.DailyReportTime(childComplexity), true
	case "Settings.defaultAIModel":
		if e.complexity.Settings.DefaultAIModel == nil {
			break
		}

		return e.complexity.Settings.DefaultAIModel(childComplexity), true
	case "Settings.defaultAIProvider":
		if e.complexity.Settings.DefaultAIProvider == nil {
			break
		}

		return e.complexity.Settings.DefaultAIProvider(childComplexity), true
	case "Settings.maxConsecutiveLoss":
		if e.complexity.Settings.MaxConsecutiveLoss == nil {
			break
		}

		return e.complexity.Settings.MaxConsecutiveLoss(childComplexity), true
	case "Settings.maxDailyDrawdown":
		if e.complexity.Settings.MaxDailyDrawdown == nil {
			break
		}

		return e.complexity.Settings.MaxDailyDrawdown(childComplexity), true
	case "Settings.maxLeverageMultiple":
		if e.complexity.Settings.MaxLeverageMultiple == nil {
			break
		}

		return e.complexity.Settings.MaxLeverageMultiple(childComplexity), true
	case "Settings.maxPortfolioRisk":
		if e.complexity.Settings.MaxPortfolioRisk == nil {
			break
		}

		return e.complexity.Settings.MaxPortfolioRisk(childComplexity), true
	case "Settings.maxPositionSizeUSD":
		if e.complexity.Settings.MaxPositionSizeUSD == nil {
			break
		}

		return e.complexity.Settings.MaxPositionSizeUSD(childComplexity), true
	case "Settings.maxPositions":
		if e.complexity.Settings.MaxPositions == nil {
			break
		}

		return e.complexity.Settings.MaxPositions(childComplexity), true
	case "Settings.maxTotalExposureUSD":
		if e.complexity.Settings.MaxTotalExposureUSD == nil {
			break
		}

		return e.complexity.Settings.MaxTotalExposureUSD(childComplexity), true
	case "Settings.minPositionSizeUSD":
		if e.complexity.Settings.MinPositionSizeUSD == nil {
			break
		}

		return e.complexity.Settings.MinPositionSizeUSD(childComplexity), true
	case "Settings.notificationsOn":
		if e.complexity.Settings.NotificationsOn == nil {
			break
		}

		return e.complexity.Settings.NotificationsOn(childComplexity), true
	case "Settings.riskLevel":
		if e.complexity.Settings.RiskLevel == nil {
			break
		}

		return e.complexity.Settings.RiskLevel(childComplexity), true
	case "Settings.timezone":
		if e.complexity.Settings.Timezone == nil {
			break
		}

		return e.complexity.Settings.Timezone(childComplexity), true

	case "Strategy.allocatedCapital":
		if e.complexity.Strategy.AllocatedCapital == nil {
			break
		}

		return e.complexity.Strategy.AllocatedCapital(childComplexity), true
	case "Strategy.cashReserve":
		if e.complexity.Strategy.CashReserve == nil {
			break
		}

		return e.complexity.Strategy.CashReserve(childComplexity), true
	case "Strategy.closedAt":
		if e.complexity.Strategy.ClosedAt == nil {
			break
		}

		return e.complexity.Strategy.ClosedAt(childComplexity), true
	case "Strategy.createdAt":
		if e.complexity.Strategy.CreatedAt == nil {
			break
		}

		return e.complexity.Strategy.CreatedAt(childComplexity), true
	case "Strategy.currentEquity":
		if e.complexity.Strategy.CurrentEquity == nil {
			break
		}

		return e.complexity.Strategy.CurrentEquity(childComplexity), true
	case "Strategy.description":
		if e.complexity.Strategy.Description == nil {
			break
		}

		return e.complexity.Strategy.Description(childComplexity), true
	case "Strategy.id":
		if e.complexity.Strategy.ID == nil {
			break
		}

		return e.complexity.Strategy.ID(childComplexity), true
	case "Strategy.lastRebalancedAt":
		if e.complexity.Strategy.LastRebalancedAt == nil {
			break
		}

		return e.complexity.Strategy.LastRebalancedAt(childComplexity), true
	case "Strategy.marketType":
		if e.complexity.Strategy.MarketType == nil {
			break
		}

		return e.complexity.Strategy.MarketType(childComplexity), true
	case "Strategy.maxDrawdown":
		if e.complexity.Strategy.MaxDrawdown == nil {
			break
		}

		return e.complexity.Strategy.MaxDrawdown(childComplexity), true
	case "Strategy.name":
		if e.complexity.Strategy.Name == nil {
			break
		}

		return e.complexity.Strategy.Name(childComplexity), true
	case "Strategy.reasoningLog":
		if e.complexity.Strategy.ReasoningLog == nil {
			break
		}

		return e.complexity.Strategy.ReasoningLog(childComplexity), true
	case "Strategy.rebalanceFrequency":
		if e.complexity.Strategy.RebalanceFrequency == nil {
			break
		}

		return e.complexity.Strategy.RebalanceFrequency(childComplexity), true
	case "Strategy.riskTolerance":
		if e.complexity.Strategy.RiskTolerance == nil {
			break
		}

		return e.complexity.Strategy.RiskTolerance(childComplexity), true
	case "Strategy.sharpeRatio":
		if e.complexity.Strategy.SharpeRatio == nil {
			break
		}

		return e.complexity.Strategy.SharpeRatio(childComplexity), true
	case "Strategy.status":
		if e.complexity.Strategy.Status == nil {
			break
		}

		return e.complexity.Strategy.Status(childComplexity), true
	case "Strategy.targetAllocations":
		if e.complexity.Strategy.TargetAllocations == nil {
			break
		}

		return e.complexity.Strategy.TargetAllocations(childComplexity), true
	case "Strategy.totalPnL":
		if e.complexity.Strategy.TotalPnL == nil {
			break
		}

		return e.complexity.Strategy.TotalPnL(childComplexity), true
	case "Strategy.totalPnLPercent":
		if e.complexity.Strategy.TotalPnLPercent == nil {
			break
		}

		return e.complexity.Strategy.TotalPnLPercent(childComplexity), true
	case "Strategy.updatedAt":
		if e.complexity.Strategy.UpdatedAt == nil {
			break
		}

		return e.complexity.Strategy.UpdatedAt(childComplexity), true
	case "Strategy.user":
		if e.complexity.Strategy.User == nil {
			break
		}

		return e.complexity.Strategy.User(childComplexity), true
	case "Strategy.userID":
		if e.complexity.Strategy.UserID == nil {
			break
		}

		return e.complexity.Strategy.UserID(childComplexity), true
	case "Strategy.winRate":
		if e.complexity.Strategy.WinRate == nil {
			break
		}

		return e.complexity.Strategy.WinRate(childComplexity), true

	case "Subscription._empty":
		if e.complexity.Subscription.Empty == nil {
			break
		}

		return e.complexity.Subscription.Empty(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true
	case "User.firstName":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true
	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true
	case "User.isActive":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true
	case "User.isPremium":
		if e.complexity.User.IsPremium == nil {
			break
		}

		return e.complexity.User.IsPremium(childComplexity), true
	case "User.languageCode":
		if e.complexity.User.LanguageCode == nil {
			break
		}

		return e.complexity.User.LanguageCode(childComplexity), true
	case "User.lastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true
	case "User.limitProfileID":
		if e.complexity.User.LimitProfileID == nil {
			break
		}

		return e.complexity.User.LimitProfileID(childComplexity), true
	case "User.settings":
		if e.complexity.User.Settings == nil {
			break
		}

		return e.complexity.User.Settings(childComplexity), true
	case "User.telegramID":
		if e.complexity.User.TelegramID == nil {
			break
		}

		return e.complexity.User.TelegramID(childComplexity), true
	case "User.telegramUsername":
		if e.complexity.User.TelegramUsername == nil {
			break
		}

		return e.complexity.User.TelegramUsername(childComplexity), true
	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateFundWatchlistInput,
		ec.unmarshalInputCreateStrategyInput,
		ec.unmarshalInputUpdateFundWatchlistInput,
		ec.unmarshalInputUpdateStrategyInput,
		ec.unmarshalInputUpdateUserSettingsInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/fund_watchlist.graphql", Input: `# Fund Watchlist types and operations

type FundWatchlist {
  id: UUID!
  symbol: String!
  marketType: String!
  
  # Metadata
  category: String!
  tier: Int!
  
  # State
  isActive: Boolean!
  isPaused: Boolean!
  pausedReason: String
  
  # Analytics
  lastAnalyzedAt: Time
  
  # Timestamps
  createdAt: Time!
  updatedAt: Time!
}

input CreateFundWatchlistInput {
  symbol: String!
  marketType: String!
  category: String!
  tier: Int!
}

input UpdateFundWatchlistInput {
  category: String
  tier: Int
  isActive: Boolean
  isPaused: Boolean
  pausedReason: String
}

# Queries
extend type Query {
  # Get watchlist item by ID
  fundWatchlist(id: UUID!): FundWatchlist
  
  # Get watchlist item by symbol
  fundWatchlistBySymbol(symbol: String!, marketType: String!): FundWatchlist
  
  # Get all watchlist items
  fundWatchlists(
    limit: Int
    offset: Int
    isActive: Boolean
    category: String
    tier: Int
  ): [FundWatchlist!]!
  
  # Get monitored symbols (active and not paused)
  monitoredSymbols(marketType: String): [FundWatchlist!]!
}

# Mutations
extend type Mutation {
  # Add symbol to watchlist
  createFundWatchlist(input: CreateFundWatchlistInput!): FundWatchlist!
  
  # Update watchlist item
  updateFundWatchlist(id: UUID!, input: UpdateFundWatchlistInput!): FundWatchlist!
  
  # Remove from watchlist
  deleteFundWatchlist(id: UUID!): Boolean!
  
  # Pause/unpause monitoring
  toggleFundWatchlistPause(id: UUID!, isPaused: Boolean!, reason: String): FundWatchlist!
}

`, BuiltIn: false},
	{Name: "../schema/scalars.graphql", Input: `# Custom scalar types

"""
UUID scalar type represents a universally unique identifier
"""
scalar UUID

"""
Time scalar type represents a timestamp in RFC3339 format
"""
scalar Time

"""
Decimal scalar type represents a high-precision decimal number
"""
scalar Decimal

"""
JSONObject scalar type represents an arbitrary JSON object
"""
scalar JSONObject

`, BuiltIn: false},
	{Name: "../schema/schema.graphql", Input: `# Root schema definition

type Query {
  # Health check
  health: String!
}

type Mutation {
  # Placeholder mutation
  _empty: String
}

type Subscription {
  # Placeholder subscription
  _empty: String
}

`, BuiltIn: false},
	{Name: "../schema/strategy.graphql", Input: `# Strategy types and operations

enum StrategyStatus {
  ACTIVE
  PAUSED
  CLOSED
}

enum MarketType {
  SPOT
  FUTURES
}

enum RiskTolerance {
  CONSERVATIVE
  MODERATE
  AGGRESSIVE
}

enum RebalanceFrequency {
  DAILY
  WEEKLY
  MONTHLY
  NEVER
}

type Strategy {
  id: UUID!
  userID: UUID!
  user: User
  
  # Strategy metadata
  name: String!
  description: String!
  status: StrategyStatus!
  
  # Capital allocation
  allocatedCapital: Decimal!
  currentEquity: Decimal!
  cashReserve: Decimal!
  
  # Configuration
  marketType: MarketType!
  riskTolerance: RiskTolerance!
  rebalanceFrequency: RebalanceFrequency!
  targetAllocations: JSONObject
  
  # Performance metrics
  totalPnL: Decimal!
  totalPnLPercent: Decimal!
  sharpeRatio: Decimal
  maxDrawdown: Decimal
  winRate: Decimal
  
  # Timestamps
  createdAt: Time!
  updatedAt: Time!
  closedAt: Time
  lastRebalancedAt: Time
  
  # Reasoning log
  reasoningLog: JSONObject
}

input CreateStrategyInput {
  name: String!
  description: String!
  allocatedCapital: Decimal!
  marketType: MarketType!
  riskTolerance: RiskTolerance!
  rebalanceFrequency: RebalanceFrequency!
  targetAllocations: JSONObject
}

input UpdateStrategyInput {
  name: String
  description: String
  riskTolerance: RiskTolerance
  rebalanceFrequency: RebalanceFrequency
  targetAllocations: JSONObject
}

# Queries
extend type Query {
  # Get strategy by ID
  strategy(id: UUID!): Strategy
  
  # Get all strategies for a user
  userStrategies(userID: UUID!, status: StrategyStatus): [Strategy!]!
  
  # Get all strategies (admin only)
  strategies(limit: Int, offset: Int, status: StrategyStatus): [Strategy!]!
}

# Mutations
extend type Mutation {
  # Create new strategy
  createStrategy(userID: UUID!, input: CreateStrategyInput!): Strategy!
  
  # Update strategy
  updateStrategy(id: UUID!, input: UpdateStrategyInput!): Strategy!
  
  # Pause strategy
  pauseStrategy(id: UUID!): Strategy!
  
  # Resume strategy
  resumeStrategy(id: UUID!): Strategy!
  
  # Close strategy
  closeStrategy(id: UUID!): Strategy!
}

`, BuiltIn: false},
	{Name: "../schema/user.graphql", Input: `# @format

# User types and operations

type User {
  id: UUID!
  telegramID: String!
  telegramUsername: String!
  firstName: String!
  lastName: String!
  languageCode: String!
  isActive: Boolean!
  isPremium: Boolean!
  limitProfileID: UUID
  settings: Settings!
  createdAt: Time!
  updatedAt: Time!
}

type Settings {
  defaultAIProvider: String!
  defaultAIModel: String!
  riskLevel: String!
  maxPositions: Int!
  maxPortfolioRisk: Float!
  maxDailyDrawdown: Float!
  maxConsecutiveLoss: Int!
  notificationsOn: Boolean!
  dailyReportTime: String!
  timezone: String!
  circuitBreakerOn: Boolean!
  maxPositionSizeUSD: Float!
  maxTotalExposureUSD: Float!
  minPositionSizeUSD: Float!
  maxLeverageMultiple: Float!
  allowedExchanges: [String!]!
}

input UpdateUserSettingsInput {
  defaultAIProvider: String
  defaultAIModel: String
  riskLevel: String
  maxPositions: Int
  maxPortfolioRisk: Float
  maxDailyDrawdown: Float
  maxConsecutiveLoss: Int
  notificationsOn: Boolean
  dailyReportTime: String
  timezone: String
  circuitBreakerOn: Boolean
  maxPositionSizeUSD: Float
  maxTotalExposureUSD: Float
  minPositionSizeUSD: Float
  maxLeverageMultiple: Float
  allowedExchanges: [String!]
}

# Queries
extend type Query {
  # Get user by ID
  user(id: UUID!): User

  # Get user by telegram ID
  userByTelegramID(telegramID: String!): User

  # Get all users (admin only)
  users(limit: Int, offset: Int): [User!]!
}

# Mutations
extend type Mutation {
  # Update user settings
  updateUserSettings(userID: UUID!, input: UpdateUserSettingsInput!): User!

  # Activate/deactivate user
  setUserActive(userID: UUID!, isActive: Boolean!): User!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_closeStrategy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFundWatchlist_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateFundWatchlistInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐCreateFundWatchlistInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createStrategy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userID", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["userID"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateStrategyInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐCreateStrategyInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFundWatchlist_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pauseStrategy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_resumeStrategy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setUserActive_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userID", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["userID"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "isActive", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["isActive"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_toggleFundWatchlistPause_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "isPaused", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["isPaused"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "reason", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["reason"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFundWatchlist_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateFundWatchlistInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐUpdateFundWatchlistInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateStrategy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateStrategyInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐUpdateStrategyInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userID", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["userID"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateUserSettingsInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐUpdateUserSettingsInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fundWatchlistBySymbol_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "symbol", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["symbol"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "marketType", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["marketType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_fundWatchlist_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fundWatchlists_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "isActive", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["isActive"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "category", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["category"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "tier", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["tier"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_monitoredSymbols_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "marketType", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["marketType"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_strategies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "status", ec.unmarshalOStrategyStatus2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus)
	if err != nil {
		return nil, err
	}
	args["status"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_strategy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userByTelegramID_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "telegramID", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["telegramID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userStrategies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userID", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["userID"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "status", ec.unmarshalOStrategyStatus2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus)
	if err != nil {
		return nil, err
	}
	args["status"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _FundWatchlist_id(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_symbol(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_symbol,
		func(ctx context.Context) (any, error) {
			return obj.Symbol, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_symbol(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_marketType(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_marketType,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.FundWatchlist().MarketType(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_marketType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_category(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_category,
		func(ctx context.Context) (any, error) {
			return obj.Category, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_tier(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_tier,
		func(ctx context.Context) (any, error) {
			return obj.Tier, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_tier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_isActive(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_isActive,
		func(ctx context.Context) (any, error) {
			return obj.IsActive, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_isActive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_isPaused(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_isPaused,
		func(ctx context.Context) (any, error) {
			return obj.IsPaused, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_isPaused(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_pausedReason(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_pausedReason,
		func(ctx context.Context) (any, error) {
			return obj.PausedReason, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_pausedReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_lastAnalyzedAt(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_lastAnalyzedAt,
		func(ctx context.Context) (any, error) {
			return obj.LastAnalyzedAt, nil
		},
		nil,
		ec.marshalOTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_lastAnalyzedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_createdAt(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FundWatchlist_updatedAt(ctx context.Context, field graphql.CollectedField, obj *fundwatchlist.Watchlist) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FundWatchlist_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FundWatchlist_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FundWatchlist",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation__empty(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation__empty,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().Empty(ctx)
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation__empty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFundWatchlist(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createFundWatchlist,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateFundWatchlist(ctx, fc.Args["input"].(CreateFundWatchlistInput))
		},
		nil,
		ec.marshalNFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createFundWatchlist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFundWatchlist_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFundWatchlist(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateFundWatchlist,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateFundWatchlist(ctx, fc.Args["id"].(uuid.UUID), fc.Args["input"].(UpdateFundWatchlistInput))
		},
		nil,
		ec.marshalNFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateFundWatchlist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFundWatchlist_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFundWatchlist(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteFundWatchlist,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteFundWatchlist(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteFundWatchlist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFundWatchlist_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_toggleFundWatchlistPause(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_toggleFundWatchlistPause,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ToggleFundWatchlistPause(ctx, fc.Args["id"].(uuid.UUID), fc.Args["isPaused"].(bool), fc.Args["reason"].(*string))
		},
		nil,
		ec.marshalNFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_toggleFundWatchlistPause(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_toggleFundWatchlistPause_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createStrategy,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateStrategy(ctx, fc.Args["userID"].(uuid.UUID), fc.Args["input"].(CreateStrategyInput))
		},
		nil,
		ec.marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateStrategy,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateStrategy(ctx, fc.Args["id"].(uuid.UUID), fc.Args["input"].(UpdateStrategyInput))
		},
		nil,
		ec.marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pauseStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_pauseStrategy,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().PauseStrategy(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_pauseStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pauseStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resumeStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_resumeStrategy,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ResumeStrategy(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_resumeStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resumeStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_closeStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_closeStrategy,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CloseStrategy(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_closeStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_closeStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateUserSettings,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateUserSettings(ctx, fc.Args["userID"].(uuid.UUID), fc.Args["input"].(UpdateUserSettingsInput))
		},
		nil,
		ec.marshalNUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "telegramID":
				return ec.fieldContext_User_telegramID(ctx, field)
			case "telegramUsername":
				return ec.fieldContext_User_telegramUsername(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "languageCode":
				return ec.fieldContext_User_languageCode(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "isPremium":
				return ec.fieldContext_User_isPremium(ctx, field)
			case "limitProfileID":
				return ec.fieldContext_User_limitProfileID(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setUserActive(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setUserActive,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetUserActive(ctx, fc.Args["userID"].(uuid.UUID), fc.Args["isActive"].(bool))
		},
		nil,
		ec.marshalNUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setUserActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "telegramID":
				return ec.fieldContext_User_telegramID(ctx, field)
			case "telegramUsername":
				return ec.fieldContext_User_telegramUsername(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "languageCode":
				return ec.fieldContext_User_languageCode(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "isPremium":
				return ec.fieldContext_User_isPremium(ctx, field)
			case "limitProfileID":
				return ec.fieldContext_User_limitProfileID(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setUserActive_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_health,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Health(ctx)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_health(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_fundWatchlist(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fundWatchlist,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FundWatchlist(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalOFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_fundWatchlist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fundWatchlist_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fundWatchlistBySymbol(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fundWatchlistBySymbol,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FundWatchlistBySymbol(ctx, fc.Args["symbol"].(string), fc.Args["marketType"].(string))
		},
		nil,
		ec.marshalOFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_fundWatchlistBySymbol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fundWatchlistBySymbol_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_fundWatchlists(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_fundWatchlists,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FundWatchlists(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int), fc.Args["isActive"].(*bool), fc.Args["category"].(*string), fc.Args["tier"].(*int))
		},
		nil,
		ec.marshalNFundWatchlist2ᚕᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlistᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_fundWatchlists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_fundWatchlists_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_monitoredSymbols(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_monitoredSymbols,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().MonitoredSymbols(ctx, fc.Args["marketType"].(*string))
		},
		nil,
		ec.marshalNFundWatchlist2ᚕᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlistᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_monitoredSymbols(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FundWatchlist_id(ctx, field)
			case "symbol":
				return ec.fieldContext_FundWatchlist_symbol(ctx, field)
			case "marketType":
				return ec.fieldContext_FundWatchlist_marketType(ctx, field)
			case "category":
				return ec.fieldContext_FundWatchlist_category(ctx, field)
			case "tier":
				return ec.fieldContext_FundWatchlist_tier(ctx, field)
			case "isActive":
				return ec.fieldContext_FundWatchlist_isActive(ctx, field)
			case "isPaused":
				return ec.fieldContext_FundWatchlist_isPaused(ctx, field)
			case "pausedReason":
				return ec.fieldContext_FundWatchlist_pausedReason(ctx, field)
			case "lastAnalyzedAt":
				return ec.fieldContext_FundWatchlist_lastAnalyzedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_FundWatchlist_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_FundWatchlist_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FundWatchlist", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_monitoredSymbols_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_strategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_strategy,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Strategy(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalOStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_strategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_strategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userStrategies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_userStrategies,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().UserStrategies(ctx, fc.Args["userID"].(uuid.UUID), fc.Args["status"].(*strategy.StrategyStatus))
		},
		nil,
		ec.marshalNStrategy2ᚕᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_userStrategies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userStrategies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_strategies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_strategies,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Strategies(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int), fc.Args["status"].(*strategy.StrategyStatus))
		},
		nil,
		ec.marshalNStrategy2ᚕᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_strategies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Strategy_id(ctx, field)
			case "userID":
				return ec.fieldContext_Strategy_userID(ctx, field)
			case "user":
				return ec.fieldContext_Strategy_user(ctx, field)
			case "name":
				return ec.fieldContext_Strategy_name(ctx, field)
			case "description":
				return ec.fieldContext_Strategy_description(ctx, field)
			case "status":
				return ec.fieldContext_Strategy_status(ctx, field)
			case "allocatedCapital":
				return ec.fieldContext_Strategy_allocatedCapital(ctx, field)
			case "currentEquity":
				return ec.fieldContext_Strategy_currentEquity(ctx, field)
			case "cashReserve":
				return ec.fieldContext_Strategy_cashReserve(ctx, field)
			case "marketType":
				return ec.fieldContext_Strategy_marketType(ctx, field)
			case "riskTolerance":
				return ec.fieldContext_Strategy_riskTolerance(ctx, field)
			case "rebalanceFrequency":
				return ec.fieldContext_Strategy_rebalanceFrequency(ctx, field)
			case "targetAllocations":
				return ec.fieldContext_Strategy_targetAllocations(ctx, field)
			case "totalPnL":
				return ec.fieldContext_Strategy_totalPnL(ctx, field)
			case "totalPnLPercent":
				return ec.fieldContext_Strategy_totalPnLPercent(ctx, field)
			case "sharpeRatio":
				return ec.fieldContext_Strategy_sharpeRatio(ctx, field)
			case "maxDrawdown":
				return ec.fieldContext_Strategy_maxDrawdown(ctx, field)
			case "winRate":
				return ec.fieldContext_Strategy_winRate(ctx, field)
			case "createdAt":
				return ec.fieldContext_Strategy_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Strategy_updatedAt(ctx, field)
			case "closedAt":
				return ec.fieldContext_Strategy_closedAt(ctx, field)
			case "lastRebalancedAt":
				return ec.fieldContext_Strategy_lastRebalancedAt(ctx, field)
			case "reasoningLog":
				return ec.fieldContext_Strategy_reasoningLog(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Strategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_strategies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_user,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().User(ctx, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalOUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "telegramID":
				return ec.fieldContext_User_telegramID(ctx, field)
			case "telegramUsername":
				return ec.fieldContext_User_telegramUsername(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "languageCode":
				return ec.fieldContext_User_languageCode(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "isPremium":
				return ec.fieldContext_User_isPremium(ctx, field)
			case "limitProfileID":
				return ec.fieldContext_User_limitProfileID(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userByTelegramID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_userByTelegramID,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().UserByTelegramID(ctx, fc.Args["telegramID"].(string))
		},
		nil,
		ec.marshalOUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_userByTelegramID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "telegramID":
				return ec.fieldContext_User_telegramID(ctx, field)
			case "telegramUsername":
				return ec.fieldContext_User_telegramUsername(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "languageCode":
				return ec.fieldContext_User_languageCode(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "isPremium":
				return ec.fieldContext_User_isPremium(ctx, field)
			case "limitProfileID":
				return ec.fieldContext_User_limitProfileID(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userByTelegramID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_users,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Users(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNUser2ᚕᚖprometheusᚋinternalᚋdomainᚋuserᚐUserᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "telegramID":
				return ec.fieldContext_User_telegramID(ctx, field)
			case "telegramUsername":
				return ec.fieldContext_User_telegramUsername(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "languageCode":
				return ec.fieldContext_User_languageCode(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "isPremium":
				return ec.fieldContext_User_isPremium(ctx, field)
			case "limitProfileID":
				return ec.fieldContext_User_limitProfileID(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_defaultAIProvider(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_defaultAIProvider,
		func(ctx context.Context) (any, error) {
			return obj.DefaultAIProvider, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_defaultAIProvider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_defaultAIModel(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_defaultAIModel,
		func(ctx context.Context) (any, error) {
			return obj.DefaultAIModel, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_defaultAIModel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_riskLevel(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_riskLevel,
		func(ctx context.Context) (any, error) {
			return obj.RiskLevel, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_riskLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxPositions(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxPositions,
		func(ctx context.Context) (any, error) {
			return obj.MaxPositions, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxPositions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxPortfolioRisk(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxPortfolioRisk,
		func(ctx context.Context) (any, error) {
			return obj.MaxPortfolioRisk, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxPortfolioRisk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxDailyDrawdown(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxDailyDrawdown,
		func(ctx context.Context) (any, error) {
			return obj.MaxDailyDrawdown, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxDailyDrawdown(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxConsecutiveLoss(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxConsecutiveLoss,
		func(ctx context.Context) (any, error) {
			return obj.MaxConsecutiveLoss, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxConsecutiveLoss(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_notificationsOn(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_notificationsOn,
		func(ctx context.Context) (any, error) {
			return obj.NotificationsOn, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_notificationsOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_dailyReportTime(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_dailyReportTime,
		func(ctx context.Context) (any, error) {
			return obj.DailyReportTime, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_dailyReportTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_timezone(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_timezone,
		func(ctx context.Context) (any, error) {
			return obj.Timezone, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_circuitBreakerOn(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_circuitBreakerOn,
		func(ctx context.Context) (any, error) {
			return obj.CircuitBreakerOn, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_circuitBreakerOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxPositionSizeUSD(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxPositionSizeUSD,
		func(ctx context.Context) (any, error) {
			return obj.MaxPositionSizeUSD, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxPositionSizeUSD(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxTotalExposureUSD(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxTotalExposureUSD,
		func(ctx context.Context) (any, error) {
			return obj.MaxTotalExposureUSD, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxTotalExposureUSD(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_minPositionSizeUSD(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_minPositionSizeUSD,
		func(ctx context.Context) (any, error) {
			return obj.MinPositionSizeUSD, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_minPositionSizeUSD(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_maxLeverageMultiple(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_maxLeverageMultiple,
		func(ctx context.Context) (any, error) {
			return obj.MaxLeverageMultiple, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_maxLeverageMultiple(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Settings_allowedExchanges(ctx context.Context, field graphql.CollectedField, obj *user.Settings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Settings_allowedExchanges,
		func(ctx context.Context) (any, error) {
			return obj.AllowedExchanges, nil
		},
		nil,
		ec.marshalNString2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Settings_allowedExchanges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_id(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_userID(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_userID,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Strategy().UserID(ctx, obj)
		},
		nil,
		ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_userID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_user(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_user,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Strategy().User(ctx, obj)
		},
		nil,
		ec.marshalOUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "telegramID":
				return ec.fieldContext_User_telegramID(ctx, field)
			case "telegramUsername":
				return ec.fieldContext_User_telegramUsername(ctx, field)
			case "firstName":
				return ec.fieldContext_User_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_User_lastName(ctx, field)
			case "languageCode":
				return ec.fieldContext_User_languageCode(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "isPremium":
				return ec.fieldContext_User_isPremium(ctx, field)
			case "limitProfileID":
				return ec.fieldContext_User_limitProfileID(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_name(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_description(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_status(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNStrategyStatus2prometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StrategyStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_allocatedCapital(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_allocatedCapital,
		func(ctx context.Context) (any, error) {
			return obj.AllocatedCapital, nil
		},
		nil,
		ec.marshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_allocatedCapital(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_currentEquity(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_currentEquity,
		func(ctx context.Context) (any, error) {
			return obj.CurrentEquity, nil
		},
		nil,
		ec.marshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_currentEquity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_cashReserve(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_cashReserve,
		func(ctx context.Context) (any, error) {
			return obj.CashReserve, nil
		},
		nil,
		ec.marshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_cashReserve(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_marketType(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_marketType,
		func(ctx context.Context) (any, error) {
			return obj.MarketType, nil
		},
		nil,
		ec.marshalNMarketType2prometheusᚋinternalᚋdomainᚋstrategyᚐMarketType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_marketType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MarketType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_riskTolerance(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_riskTolerance,
		func(ctx context.Context) (any, error) {
			return obj.RiskTolerance, nil
		},
		nil,
		ec.marshalNRiskTolerance2prometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_riskTolerance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RiskTolerance does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_rebalanceFrequency(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_rebalanceFrequency,
		func(ctx context.Context) (any, error) {
			return obj.RebalanceFrequency, nil
		},
		nil,
		ec.marshalNRebalanceFrequency2prometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_rebalanceFrequency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RebalanceFrequency does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_targetAllocations(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_targetAllocations,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Strategy().TargetAllocations(ctx, obj)
		},
		nil,
		ec.marshalOJSONObject2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_targetAllocations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSONObject does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_totalPnL(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_totalPnL,
		func(ctx context.Context) (any, error) {
			return obj.TotalPnL, nil
		},
		nil,
		ec.marshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_totalPnL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_totalPnLPercent(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_totalPnLPercent,
		func(ctx context.Context) (any, error) {
			return obj.TotalPnLPercent, nil
		},
		nil,
		ec.marshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_totalPnLPercent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_sharpeRatio(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_sharpeRatio,
		func(ctx context.Context) (any, error) {
			return obj.SharpeRatio, nil
		},
		nil,
		ec.marshalODecimal2ᚖgithubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_sharpeRatio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_maxDrawdown(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_maxDrawdown,
		func(ctx context.Context) (any, error) {
			return obj.MaxDrawdown, nil
		},
		nil,
		ec.marshalODecimal2ᚖgithubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_maxDrawdown(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_winRate(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_winRate,
		func(ctx context.Context) (any, error) {
			return obj.WinRate, nil
		},
		nil,
		ec.marshalODecimal2ᚖgithubᚗcomᚋshopspringᚋdecimalᚐDecimal,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_winRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Decimal does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_createdAt(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_updatedAt(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Strategy_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_closedAt(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_closedAt,
		func(ctx context.Context) (any, error) {
			return obj.ClosedAt, nil
		},
		nil,
		ec.marshalOTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_closedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_lastRebalancedAt(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_lastRebalancedAt,
		func(ctx context.Context) (any, error) {
			return obj.LastRebalancedAt, nil
		},
		nil,
		ec.marshalOTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_lastRebalancedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Strategy_reasoningLog(ctx context.Context, field graphql.CollectedField, obj *strategy.Strategy) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Strategy_reasoningLog,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Strategy().ReasoningLog(ctx, obj)
		},
		nil,
		ec.marshalOJSONObject2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Strategy_reasoningLog(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Strategy",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSONObject does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription__empty(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription__empty,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Subscription().Empty(ctx)
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscription__empty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_telegramID(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_telegramID,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().TelegramID(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_telegramID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_telegramUsername(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_telegramUsername,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().TelegramUsername(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_telegramUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_firstName(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_firstName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().FirstName(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_firstName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_lastName(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_lastName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().LastName(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_lastName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_languageCode(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_languageCode,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().LanguageCode(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_languageCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_isActive(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_isActive,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().IsActive(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_isActive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_isPremium(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_isPremium,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().IsPremium(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_isPremium(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_limitProfileID(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_limitProfileID,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().LimitProfileID(ctx, obj)
		},
		nil,
		ec.marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_limitProfileID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_settings(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_settings,
		func(ctx context.Context) (any, error) {
			return obj.Settings, nil
		},
		nil,
		ec.marshalNSettings2prometheusᚋinternalᚋdomainᚋuserᚐSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_settings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultAIProvider":
				return ec.fieldContext_Settings_defaultAIProvider(ctx, field)
			case "defaultAIModel":
				return ec.fieldContext_Settings_defaultAIModel(ctx, field)
			case "riskLevel":
				return ec.fieldContext_Settings_riskLevel(ctx, field)
			case "maxPositions":
				return ec.fieldContext_Settings_maxPositions(ctx, field)
			case "maxPortfolioRisk":
				return ec.fieldContext_Settings_maxPortfolioRisk(ctx, field)
			case "maxDailyDrawdown":
				return ec.fieldContext_Settings_maxDailyDrawdown(ctx, field)
			case "maxConsecutiveLoss":
				return ec.fieldContext_Settings_maxConsecutiveLoss(ctx, field)
			case "notificationsOn":
				return ec.fieldContext_Settings_notificationsOn(ctx, field)
			case "dailyReportTime":
				return ec.fieldContext_Settings_dailyReportTime(ctx, field)
			case "timezone":
				return ec.fieldContext_Settings_timezone(ctx, field)
			case "circuitBreakerOn":
				return ec.fieldContext_Settings_circuitBreakerOn(ctx, field)
			case "maxPositionSizeUSD":
				return ec.fieldContext_Settings_maxPositionSizeUSD(ctx, field)
			case "maxTotalExposureUSD":
				return ec.fieldContext_Settings_maxTotalExposureUSD(ctx, field)
			case "minPositionSizeUSD":
				return ec.fieldContext_Settings_minPositionSizeUSD(ctx, field)
			case "maxLeverageMultiple":
				return ec.fieldContext_Settings_maxLeverageMultiple(ctx, field)
			case "allowedExchanges":
				return ec.fieldContext_Settings_allowedExchanges(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Settings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *user.User) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateFundWatchlistInput(ctx context.Context, obj any) (CreateFundWatchlistInput, error) {
	var it CreateFundWatchlistInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"symbol", "marketType", "category", "tier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "symbol":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("symbol"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Symbol = data
		case "marketType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("marketType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MarketType = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateStrategyInput(ctx context.Context, obj any) (CreateStrategyInput, error) {
	var it CreateStrategyInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "allocatedCapital", "marketType", "riskTolerance", "rebalanceFrequency", "targetAllocations"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "allocatedCapital":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocatedCapital"))
			data, err := ec.unmarshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllocatedCapital = data
		case "marketType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("marketType"))
			data, err := ec.unmarshalNMarketType2prometheusᚋinternalᚋdomainᚋstrategyᚐMarketType(ctx, v)
			if err != nil {
				return it, err
			}
			it.MarketType = data
		case "riskTolerance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("riskTolerance"))
			data, err := ec.unmarshalNRiskTolerance2prometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance(ctx, v)
			if err != nil {
				return it, err
			}
			it.RiskTolerance = data
		case "rebalanceFrequency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rebalanceFrequency"))
			data, err := ec.unmarshalNRebalanceFrequency2prometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency(ctx, v)
			if err != nil {
				return it, err
			}
			it.RebalanceFrequency = data
		case "targetAllocations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetAllocations"))
			data, err := ec.unmarshalOJSONObject2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetAllocations = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateFundWatchlistInput(ctx context.Context, obj any) (UpdateFundWatchlistInput, error) {
	var it UpdateFundWatchlistInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"category", "tier", "isActive", "isPaused", "pausedReason"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		case "isActive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isActive"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsActive = data
		case "isPaused":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPaused"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPaused = data
		case "pausedReason":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pausedReason"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PausedReason = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateStrategyInput(ctx context.Context, obj any) (UpdateStrategyInput, error) {
	var it UpdateStrategyInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "riskTolerance", "rebalanceFrequency", "targetAllocations"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "riskTolerance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("riskTolerance"))
			data, err := ec.unmarshalORiskTolerance2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance(ctx, v)
			if err != nil {
				return it, err
			}
			it.RiskTolerance = data
		case "rebalanceFrequency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rebalanceFrequency"))
			data, err := ec.unmarshalORebalanceFrequency2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency(ctx, v)
			if err != nil {
				return it, err
			}
			it.RebalanceFrequency = data
		case "targetAllocations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetAllocations"))
			data, err := ec.unmarshalOJSONObject2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetAllocations = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserSettingsInput(ctx context.Context, obj any) (UpdateUserSettingsInput, error) {
	var it UpdateUserSettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"defaultAIProvider", "defaultAIModel", "riskLevel", "maxPositions", "maxPortfolioRisk", "maxDailyDrawdown", "maxConsecutiveLoss", "notificationsOn", "dailyReportTime", "timezone", "circuitBreakerOn", "maxPositionSizeUSD", "maxTotalExposureUSD", "minPositionSizeUSD", "maxLeverageMultiple", "allowedExchanges"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "defaultAIProvider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultAIProvider"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultAIProvider = data
		case "defaultAIModel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultAIModel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultAIModel = data
		case "riskLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("riskLevel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RiskLevel = data
		case "maxPositions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPositions"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPositions = data
		case "maxPortfolioRisk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPortfolioRisk"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPortfolioRisk = data
		case "maxDailyDrawdown":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDailyDrawdown"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDailyDrawdown = data
		case "maxConsecutiveLoss":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxConsecutiveLoss"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxConsecutiveLoss = data
		case "notificationsOn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notificationsOn"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotificationsOn = data
		case "dailyReportTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyReportTime"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyReportTime = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "circuitBreakerOn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("circuitBreakerOn"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CircuitBreakerOn = data
		case "maxPositionSizeUSD":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPositionSizeUSD"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPositionSizeUsd = data
		case "maxTotalExposureUSD":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTotalExposureUSD"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTotalExposureUsd = data
		case "minPositionSizeUSD":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minPositionSizeUSD"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinPositionSizeUsd = data
		case "maxLeverageMultiple":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxLeverageMultiple"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLeverageMultiple = data
		case "allowedExchanges":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedExchanges"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedExchanges = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var fundWatchlistImplementors = []string{"FundWatchlist"}

func (ec *executionContext) _FundWatchlist(ctx context.Context, sel ast.SelectionSet, obj *fundwatchlist.Watchlist) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fundWatchlistImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FundWatchlist")
		case "id":
			out.Values[i] = ec._FundWatchlist_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "symbol":
			out.Values[i] = ec._FundWatchlist_symbol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "marketType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FundWatchlist_marketType(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "category":
			out.Values[i] = ec._FundWatchlist_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tier":
			out.Values[i] = ec._FundWatchlist_tier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isActive":
			out.Values[i] = ec._FundWatchlist_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isPaused":
			out.Values[i] = ec._FundWatchlist_isPaused(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pausedReason":
			out.Values[i] = ec._FundWatchlist_pausedReason(ctx, field, obj)
		case "lastAnalyzedAt":
			out.Values[i] = ec._FundWatchlist_lastAnalyzedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._FundWatchlist_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._FundWatchlist_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "_empty":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation__empty(ctx, field)
			})
		case "createFundWatchlist":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFundWatchlist(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFundWatchlist":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFundWatchlist(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFundWatchlist":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFundWatchlist(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "toggleFundWatchlistPause":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_toggleFundWatchlistPause(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createStrategy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createStrategy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateStrategy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateStrategy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pauseStrategy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pauseStrategy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resumeStrategy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resumeStrategy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "closeStrategy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_closeStrategy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserSettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setUserActive":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setUserActive(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "health":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_health(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fundWatchlist":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fundWatchlist(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fundWatchlistBySymbol":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fundWatchlistBySymbol(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fundWatchlists":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fundWatchlists(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "monitoredSymbols":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_monitoredSymbols(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "strategy":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_strategy(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userStrategies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userStrategies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "strategies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_strategies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userByTelegramID":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userByTelegramID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var settingsImplementors = []string{"Settings"}

func (ec *executionContext) _Settings(ctx context.Context, sel ast.SelectionSet, obj *user.Settings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, settingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Settings")
		case "defaultAIProvider":
			out.Values[i] = ec._Settings_defaultAIProvider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultAIModel":
			out.Values[i] = ec._Settings_defaultAIModel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "riskLevel":
			out.Values[i] = ec._Settings_riskLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPositions":
			out.Values[i] = ec._Settings_maxPositions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPortfolioRisk":
			out.Values[i] = ec._Settings_maxPortfolioRisk(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDailyDrawdown":
			out.Values[i] = ec._Settings_maxDailyDrawdown(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxConsecutiveLoss":
			out.Values[i] = ec._Settings_maxConsecutiveLoss(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notificationsOn":
			out.Values[i] = ec._Settings_notificationsOn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dailyReportTime":
			out.Values[i] = ec._Settings_dailyReportTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timezone":
			out.Values[i] = ec._Settings_timezone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "circuitBreakerOn":
			out.Values[i] = ec._Settings_circuitBreakerOn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxPositionSizeUSD":
			out.Values[i] = ec._Settings_maxPositionSizeUSD(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxTotalExposureUSD":
			out.Values[i] = ec._Settings_maxTotalExposureUSD(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minPositionSizeUSD":
			out.Values[i] = ec._Settings_minPositionSizeUSD(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxLeverageMultiple":
			out.Values[i] = ec._Settings_maxLeverageMultiple(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedExchanges":
			out.Values[i] = ec._Settings_allowedExchanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var strategyImplementors = []string{"Strategy"}

func (ec *executionContext) _Strategy(ctx context.Context, sel ast.SelectionSet, obj *strategy.Strategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, strategyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Strategy")
		case "id":
			out.Values[i] = ec._Strategy_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Strategy_userID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Strategy_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._Strategy_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Strategy_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Strategy_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "allocatedCapital":
			out.Values[i] = ec._Strategy_allocatedCapital(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "currentEquity":
			out.Values[i] = ec._Strategy_currentEquity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cashReserve":
			out.Values[i] = ec._Strategy_cashReserve(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "marketType":
			out.Values[i] = ec._Strategy_marketType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "riskTolerance":
			out.Values[i] = ec._Strategy_riskTolerance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rebalanceFrequency":
			out.Values[i] = ec._Strategy_rebalanceFrequency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetAllocations":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Strategy_targetAllocations(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "totalPnL":
			out.Values[i] = ec._Strategy_totalPnL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalPnLPercent":
			out.Values[i] = ec._Strategy_totalPnLPercent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sharpeRatio":
			out.Values[i] = ec._Strategy_sharpeRatio(ctx, field, obj)
		case "maxDrawdown":
			out.Values[i] = ec._Strategy_maxDrawdown(ctx, field, obj)
		case "winRate":
			out.Values[i] = ec._Strategy_winRate(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Strategy_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Strategy_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "closedAt":
			out.Values[i] = ec._Strategy_closedAt(ctx, field, obj)
		case "lastRebalancedAt":
			out.Values[i] = ec._Strategy_lastRebalancedAt(ctx, field, obj)
		case "reasoningLog":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Strategy_reasoningLog(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		graphql.AddErrorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "_empty":
		return ec._Subscription__empty(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *user.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "telegramID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_telegramID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "telegramUsername":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_telegramUsername(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "firstName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_firstName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_lastName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "languageCode":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_languageCode(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isActive":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_isActive(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isPremium":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_isPremium(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "limitProfileID":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_limitProfileID(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "settings":
			out.Values[i] = ec._User_settings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._User_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateFundWatchlistInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐCreateFundWatchlistInput(ctx context.Context, v any) (CreateFundWatchlistInput, error) {
	res, err := ec.unmarshalInputCreateFundWatchlistInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateStrategyInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐCreateStrategyInput(ctx context.Context, v any) (CreateStrategyInput, error) {
	res, err := ec.unmarshalInputCreateStrategyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal(ctx context.Context, v any) (decimal.Decimal, error) {
	res, err := ec.unmarshalInputDecimal(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDecimal2githubᚗcomᚋshopspringᚋdecimalᚐDecimal(ctx context.Context, sel ast.SelectionSet, v decimal.Decimal) graphql.Marshaler {
	return ec._Decimal(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFundWatchlist2prometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist(ctx context.Context, sel ast.SelectionSet, v fundwatchlist.Watchlist) graphql.Marshaler {
	return ec._FundWatchlist(ctx, sel, &v)
}

func (ec *executionContext) marshalNFundWatchlist2ᚕᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlistᚄ(ctx context.Context, sel ast.SelectionSet, v []*fundwatchlist.Watchlist) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist(ctx context.Context, sel ast.SelectionSet, v *fundwatchlist.Watchlist) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FundWatchlist(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMarketType2prometheusᚋinternalᚋdomainᚋstrategyᚐMarketType(ctx context.Context, v any) (strategy.MarketType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.MarketType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMarketType2prometheusᚋinternalᚋdomainᚋstrategyᚐMarketType(ctx context.Context, sel ast.SelectionSet, v strategy.MarketType) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNRebalanceFrequency2prometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency(ctx context.Context, v any) (strategy.RebalanceFrequency, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.RebalanceFrequency(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRebalanceFrequency2prometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency(ctx context.Context, sel ast.SelectionSet, v strategy.RebalanceFrequency) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNRiskTolerance2prometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance(ctx context.Context, v any) (strategy.RiskTolerance, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.RiskTolerance(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRiskTolerance2prometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance(ctx context.Context, sel ast.SelectionSet, v strategy.RiskTolerance) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSettings2prometheusᚋinternalᚋdomainᚋuserᚐSettings(ctx context.Context, sel ast.SelectionSet, v user.Settings) graphql.Marshaler {
	return ec._Settings(ctx, sel, &v)
}

func (ec *executionContext) marshalNStrategy2prometheusᚋinternalᚋdomainᚋstrategyᚐStrategy(ctx context.Context, sel ast.SelectionSet, v strategy.Strategy) graphql.Marshaler {
	return ec._Strategy(ctx, sel, &v)
}

func (ec *executionContext) marshalNStrategy2ᚕᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyᚄ(ctx context.Context, sel ast.SelectionSet, v []*strategy.Strategy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy(ctx context.Context, sel ast.SelectionSet, v *strategy.Strategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Strategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStrategyStatus2prometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus(ctx context.Context, v any) (strategy.StrategyStatus, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.StrategyStatus(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStrategyStatus2prometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus(ctx context.Context, sel ast.SelectionSet, v strategy.StrategyStatus) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := ec.unmarshalInputTime(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return ec._Time(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v any) (uuid.UUID, error) {
	res, err := ec.unmarshalInputUUID(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	return ec._UUID(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUpdateFundWatchlistInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐUpdateFundWatchlistInput(ctx context.Context, v any) (UpdateFundWatchlistInput, error) {
	res, err := ec.unmarshalInputUpdateFundWatchlistInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateStrategyInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐUpdateStrategyInput(ctx context.Context, v any) (UpdateStrategyInput, error) {
	res, err := ec.unmarshalInputUpdateStrategyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserSettingsInput2prometheusᚋinternalᚋapiᚋgraphqlᚋgeneratedᚐUpdateUserSettingsInput(ctx context.Context, v any) (UpdateUserSettingsInput, error) {
	res, err := ec.unmarshalInputUpdateUserSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2prometheusᚋinternalᚋdomainᚋuserᚐUser(ctx context.Context, sel ast.SelectionSet, v user.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖprometheusᚋinternalᚋdomainᚋuserᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*user.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser(ctx context.Context, sel ast.SelectionSet, v *user.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODecimal2ᚖgithubᚗcomᚋshopspringᚋdecimalᚐDecimal(ctx context.Context, v any) (*decimal.Decimal, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDecimal(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODecimal2ᚖgithubᚗcomᚋshopspringᚋdecimalᚐDecimal(ctx context.Context, sel ast.SelectionSet, v *decimal.Decimal) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Decimal(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOFundWatchlist2ᚖprometheusᚋinternalᚋdomainᚋfundwatchlistᚐWatchlist(ctx context.Context, sel ast.SelectionSet, v *fundwatchlist.Watchlist) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FundWatchlist(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOJSONObject2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJSONObject(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSONObject2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JSONObject(ctx, sel, v)
}

func (ec *executionContext) unmarshalORebalanceFrequency2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency(ctx context.Context, v any) (*strategy.RebalanceFrequency, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.RebalanceFrequency(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORebalanceFrequency2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐRebalanceFrequency(ctx context.Context, sel ast.SelectionSet, v *strategy.RebalanceFrequency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalORiskTolerance2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance(ctx context.Context, v any) (*strategy.RiskTolerance, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.RiskTolerance(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORiskTolerance2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐRiskTolerance(ctx context.Context, sel ast.SelectionSet, v *strategy.RiskTolerance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOStrategy2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategy(ctx context.Context, sel ast.SelectionSet, v *strategy.Strategy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Strategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStrategyStatus2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus(ctx context.Context, v any) (*strategy.StrategyStatus, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := strategy.StrategyStatus(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStrategyStatus2ᚖprometheusᚋinternalᚋdomainᚋstrategyᚐStrategyStatus(ctx context.Context, sel ast.SelectionSet, v *strategy.StrategyStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTime(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Time(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v any) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUUID(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UUID(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2ᚖprometheusᚋinternalᚋdomainᚋuserᚐUser(ctx context.Context, sel ast.SelectionSet, v *user.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
